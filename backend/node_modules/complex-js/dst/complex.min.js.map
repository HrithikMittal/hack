{"version":3,"file":"complex.min.js","sources":["../functions/from.ts","../internal/imagImpl.ts","../methods/getImag.ts","../internal/realImpl.ts","../methods/getReal.ts","../methods/add.ts","../methods/and.ts","../internal/absImpl.ts","../methods/getAbs.ts","../internal/argImpl.ts","../methods/getArg.ts","../methods/div.ts","../functions/trunc.ts","../methods/mul.ts","../methods/sub.ts","../methods/mod.ts","../methods/or.ts","../functions/cube.ts","../functions/square.ts","../methods/pow.ts","../methods/sal.ts","../methods/sar.ts","../methods/shr.ts","../methods/xor.ts","../compiler/binary.ts","../functions/abs.ts","../functions/log.ts","../functions/sqrt.ts","../functions/acos.ts","../functions/acosh.ts","../functions/arg.ts","../functions/asin.ts","../functions/asinh.ts","../functions/atan.ts","../functions/atanh.ts","../functions/cbrt.ts","../functions/ceil.ts","../functions/conj.ts","../functions/cos.ts","../functions/cosh.ts","../functions/exp.ts","../functions/floor.ts","../functions/imag.ts","../functions/random.ts","../functions/real.ts","../functions/round.ts","../functions/sign.ts","../functions/sin.ts","../functions/sinh.ts","../functions/tan.ts","../functions/tanh.ts","../compiler/call.ts","../functions/neg.ts","../functions/not.ts","../compiler/unary.ts","../compiler/expressions.ts","../compiler/grammar.ts","../compiler/generate.ts","../methods/toString.ts","../complex.ts","../functions/polar.ts","../compiler/parse.ts","../compiler/compile.ts","../methods/equals.ts"],"sourcesContent":["import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function from<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n  let zAbs: number;\r\n  let zArg: number;\r\n  let zMask: mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n    zAbs = NaN;\r\n    zArg = NaN;\r\n    zMask = mask.HAS_CARTESIAN;\r\n  } else {\r\n    // to prevent null values from entering into arithmetic operations\r\n    // e.g. Complex.from(JSON.parse(text))\r\n    zReal = z._real ?? NaN;\r\n    zImag = z._imag ?? NaN;\r\n    zAbs = z._abs ?? NaN;\r\n    zArg = z._arg ?? NaN;\r\n    zMask = z._mask;\r\n  }\r\n\r\n  return new Complex(zReal, zImag, zAbs, zArg, zMask);\r\n}\r\n","export default function imagImpl (abs: number, arg: number): number {\r\n  return (\r\n    // if z is real, imag = 0\r\n    arg === 0 || arg === Math.PI ? 0\r\n    // else imag = abs * sin(arg)\r\n    : abs * Math.sin(arg)\r\n  );\r\n}\r\n","import { IComplex } from '../internal/complex';\r\nimport imagImpl from '../internal/imagImpl';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function getImag (z: IComplex): number {\r\n  if (!(z._mask & mask.HAS_IMAG)) {\r\n    z._imag = imagImpl(z._abs, z._arg);\r\n    z._mask |= mask.HAS_IMAG;\r\n  }\r\n\r\n  return z._imag;\r\n}\r\n","export default function realImpl (abs: number, arg: number): number {\r\n  return (\r\n    // if z is positive, real = abs\r\n    arg === 0 ? abs\r\n    // if z is negative, real = -abs\r\n    : arg === Math.PI ? -abs\r\n    // else real = abs * cos(arg)\r\n    : abs * Math.cos(arg)\r\n  );\r\n}\r\n","import { IComplex } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport realImpl from '../internal/realImpl';\r\n\r\nexport default function getReal (z: IComplex): number {\r\n  if (!(z._mask & mask.HAS_REAL)) {\r\n    z._real = realImpl(z._abs, z._arg);\r\n    z._mask |= mask.HAS_REAL;\r\n  }\r\n\r\n  return z._real;\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function add<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(lhsReal + rhsReal, lhsImag + rhsImag, NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function and<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(lhsReal & rhsReal, lhsImag & rhsImag, NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","export default function absImpl (real: number, imag: number): number {\r\n  return (\r\n    // if z is real, abs = |real|\r\n    imag === 0 ? Math.abs(real)\r\n    // if z is imag, abs = |imag|\r\n    : real === 0 ? Math.abs(imag)\r\n    // else abs = |z|\r\n    : Math.hypot(real, imag)\r\n  );\r\n}\r\n","import absImpl from '../internal/absImpl';\r\nimport { IComplex } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function getAbs (z: IComplex): number {\r\n  if (!(z._mask & mask.HAS_ABS)) {\r\n    z._abs = absImpl(z._real, z._imag);\r\n    z._mask |= mask.HAS_ABS;\r\n  }\r\n\r\n  return z._abs;\r\n}\r\n","export default function argImpl (real: number, imag: number): number {\r\n  return (\r\n    // if z is real, if z is negative, arg = pi, else arg = 0\r\n    imag === 0 ? (real < 0 ? Math.PI : 0)\r\n    // if z is imag, arg = sign(imag) * pi / 2\r\n    : real === 0 ? (imag < 0 ? -0.5 : 0.5) * Math.PI\r\n    // else arg = atan(imag / real)\r\n    : Math.atan2(imag, real)\r\n  );\r\n}\r\n","import argImpl from '../internal/argImpl';\r\nimport { IComplex } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function getArg (z: IComplex): number {\r\n  if (!(z._mask & mask.HAS_ARG)) {\r\n    z._arg = argImpl(z._real, z._imag);\r\n    z._mask |= mask.HAS_ARG;\r\n  }\r\n\r\n  return z._arg;\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from './getAbs';\r\nimport getArg from './getArg';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function div<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  const rhs = typeof r === 'number'\r\n    ? new Complex(r, i, NaN, NaN, mask.HAS_CARTESIAN)\r\n    : r;\r\n\r\n  const _mask = lhs._mask & rhs._mask;\r\n  let rhsAbs2: number;\r\n\r\n  switch (_mask) {\r\n    case mask.HAS_ALL:\r\n    case mask.HAS_CARTESIAN | mask.HAS_ABS:\r\n      rhsAbs2 = rhs._abs * rhs._abs;\r\n      return new Complex(\r\n        (lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2,\r\n        (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2,\r\n        lhs._abs / rhs._abs,\r\n        lhs._arg - rhs._arg,\r\n        _mask\r\n      );\r\n    case mask.HAS_CARTESIAN | mask.HAS_ARG:\r\n      rhsAbs2 = rhs._real * rhs._real + rhs._imag * rhs._imag;\r\n      return new Complex(\r\n        (lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2,\r\n        (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2,\r\n        NaN,\r\n        lhs._arg - rhs._arg,\r\n        _mask\r\n      );\r\n    case mask.HAS_CARTESIAN:\r\n    case mask.HAS_REAL:\r\n    case mask.HAS_IMAG:\r\n      rhsAbs2 = getReal(rhs) * rhs._real + getImag(rhs) * rhs._imag;\r\n      return new Complex(\r\n        (getReal(lhs) * rhs._real + getImag(lhs) * rhs._imag) / rhsAbs2,\r\n        (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2,\r\n        NaN,\r\n        NaN,\r\n        mask.HAS_CARTESIAN\r\n      );\r\n    default:\r\n      return new Complex(\r\n        NaN,\r\n        NaN,\r\n        getAbs(lhs) / getAbs(rhs),\r\n        getArg(lhs) - getArg(rhs),\r\n        mask.HAS_POLAR\r\n      );\r\n  }\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function trunc<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.trunc(zReal), Math.trunc(zImag), NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from './getAbs';\r\nimport getArg from './getArg';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function mul<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  const rhs = typeof r === 'number'\r\n    ? new Complex(r, i, NaN, NaN, mask.HAS_CARTESIAN)\r\n    : r;\r\n\r\n  const _mask = lhs._mask & rhs._mask;\r\n\r\n  switch (_mask) {\r\n    case mask.HAS_ALL:\r\n    case mask.HAS_CARTESIAN | mask.HAS_ABS:\r\n    case mask.HAS_CARTESIAN | mask.HAS_ARG:\r\n    case mask.HAS_CARTESIAN:\r\n      return new Complex(\r\n        lhs._real * rhs._real - lhs._imag * rhs._imag,\r\n        lhs._imag * rhs._real + lhs._real * rhs._imag,\r\n        lhs._abs * rhs._abs,\r\n        lhs._arg + rhs._arg,\r\n        _mask\r\n      );\r\n    case mask.HAS_REAL:\r\n    case mask.HAS_IMAG:\r\n      return new Complex(\r\n        getReal(lhs) * getReal(rhs) - getImag(lhs) * getImag(rhs),\r\n        lhs._imag * rhs._real + lhs._real * rhs._imag,\r\n        NaN,\r\n        NaN,\r\n        mask.HAS_CARTESIAN\r\n      );\r\n    default:\r\n      return new Complex(\r\n        NaN,\r\n        NaN,\r\n        getAbs(lhs) * getAbs(rhs),\r\n        getArg(lhs) + getArg(rhs),\r\n        mask.HAS_POLAR\r\n      );\r\n  }\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function sub<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(\r\n    lhsReal - rhsReal,\r\n    lhsImag - rhsImag,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import trunc from '../functions/trunc';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport div from './div';\r\nimport mul from './mul';\r\nimport sub from './sub';\r\n\r\nexport default function mod<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  // lhs % rhs = lhs - (trunc(lhs / rhs) * rhs)\r\n  const q = div(Complex, lhs, r, i);\r\n  const p = mul(Complex, trunc(Complex, q), r, i);\r\n\r\n  return sub(Complex, lhs, p);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function or<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(\r\n    lhsReal | rhsReal,\r\n    lhsImag | rhsImag,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function cube<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n  let zAbs: number;\r\n  let zArg: number;\r\n  let zMask: mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n    zAbs = NaN;\r\n    zArg = NaN;\r\n    zMask = mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real;\r\n    zImag = z._imag;\r\n    zAbs = z._abs;\r\n    zArg = z._arg;\r\n    zMask = z._mask;\r\n  }\r\n\r\n  if ((zMask & mask.HAS_CARTESIAN) !== mask.HAS_CARTESIAN) {\r\n    return new Complex(NaN, NaN, zAbs * zAbs * zAbs, 3 * zArg, mask.HAS_POLAR);\r\n  }\r\n\r\n  const real2 = zReal * zReal;\r\n  const imag2 = zImag * zImag;\r\n\r\n  return new Complex(\r\n    (real2 - 3 * imag2) * zReal,\r\n    (3 * real2 - imag2) * zImag,\r\n    zAbs * zAbs * zAbs,\r\n    3 * zArg,\r\n    zMask\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function square<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n  let zAbs: number;\r\n  let zArg: number;\r\n  let zMask: mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n    zAbs = NaN;\r\n    zArg = NaN;\r\n    zMask = mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real;\r\n    zImag = z._imag;\r\n    zAbs = z._abs;\r\n    zArg = z._arg;\r\n    zMask = z._mask;\r\n  }\r\n\r\n  if ((zMask & mask.HAS_CARTESIAN) !== mask.HAS_CARTESIAN) {\r\n    return new Complex(NaN, NaN, zAbs * zAbs, 2 * zArg, mask.HAS_POLAR);\r\n  }\r\n\r\n  const real2 = zReal * zReal;\r\n  const imag2 = zImag * zImag;\r\n\r\n  return new Complex(\r\n    real2 - imag2,\r\n    2 * zReal * zImag,\r\n    real2 + imag2,\r\n    2 * zArg,\r\n    zMask | mask.HAS_ABS\r\n  );\r\n}\r\n","import cube from '../functions/cube';\r\nimport from from '../functions/from';\r\nimport square from '../functions/square';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport div from './div';\r\nimport getAbs from './getAbs';\r\nimport getArg from './getArg';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function pow<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  // rhs = c + di\r\n  let c: number;\r\n  let d: number;\r\n\r\n  if (typeof r === 'number') {\r\n    c = r;\r\n    d = i;\r\n  } else {\r\n    c = getReal(r);\r\n    d = getImag(r);\r\n  }\r\n\r\n  if (d === 0) {\r\n    switch (c) {\r\n      case -1: return div(Complex, from(Complex, 1), lhs);\r\n      case 0: return from(Complex, 1);\r\n      case 1: return from(Complex, lhs);\r\n      case 2: return square(Complex, lhs);\r\n      case 3: return cube(Complex, lhs);\r\n    }\r\n  }\r\n\r\n  // lhs = m e ** ia\r\n  const m = getAbs(lhs);\r\n  const a = getArg(lhs);\r\n\r\n  // lhs ** rhs === (m ** c * e ** -ad) e ** i(d ln(m) + ac)\r\n  // from https://en.wikipedia.org/wiki/Exponentiation#Computing_complex_powers\r\n  const abs = Math.pow(m, c) * Math.exp(-a * d);\r\n  const arg = d * Math.log(m) + a * c;\r\n\r\n  return new Complex(NaN, NaN, abs, arg, mask.HAS_POLAR);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function sal<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(\r\n    lhsReal << rhsReal,\r\n    lhsImag << rhsImag,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function sar<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(\r\n    lhsReal >> rhsReal,\r\n    lhsImag >> rhsImag,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function shr<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(\r\n    lhsReal >>> rhsReal,\r\n    lhsImag >>> rhsImag,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function xor<T extends IComplex> (Complex: IComplexConstructor<T>, lhs: IComplex, r: IComplex | number, i = 0): T {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return new Complex(\r\n    lhsReal ^ rhsReal,\r\n    lhsImag ^ rhsImag,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import add from '../methods/add';\nimport and from '../methods/and';\nimport div from '../methods/div';\nimport mod from '../methods/mod';\nimport mul from '../methods/mul';\nimport or from '../methods/or';\nimport pow from '../methods/pow';\nimport sal from '../methods/sal';\nimport sar from '../methods/sar';\nimport shr from '../methods/shr';\nimport sub from '../methods/sub';\nimport xor from '../methods/xor';\n\nexport const binaryLookup = {\n  '%': mod,\n  '&': and,\n  '*': mul,\n  '**': pow,\n  '+': add,\n  '-': sub,\n  '/': div,\n  '<<': sal,\n  '>>': sar,\n  '>>>': shr,\n  '^': xor,\n  '|': or\n};\n\nexport type Binary = typeof binaryLookup;\n","import absImpl from '../internal/absImpl';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from '../methods/getAbs';\r\n\r\nexport default function abs<T extends IComplex>(Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const zAbs = typeof z === 'number'\r\n    ? absImpl(z, i)\r\n    : getAbs(z);\r\n\r\n  return new Complex(zAbs, 0, zAbs, 0, mask.HAS_ALL);\r\n}\r\n","import absImpl from '../internal/absImpl';\r\nimport argImpl from '../internal/argImpl';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from '../methods/getAbs';\r\nimport getArg from '../methods/getArg';\r\n\r\nexport default function log<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zAbs: number;\r\n  let zArg: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zAbs = absImpl(z, i);\r\n    zArg = argImpl(z, i);\r\n  } else {\r\n    zAbs = getAbs(z);\r\n    zArg = getArg(z);\r\n  }\r\n\r\n  return new Complex(\r\n    Math.log(zAbs),\r\n    zArg,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import absImpl from '../internal/absImpl';\r\nimport argImpl from '../internal/argImpl';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from '../methods/getAbs';\r\nimport getArg from '../methods/getArg';\r\n\r\nexport default function sqrt<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zAbs: number;\r\n  let zArg: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zAbs = absImpl(z, i);\r\n    zArg = argImpl(z, i);\r\n  } else {\r\n    zAbs = getAbs(z);\r\n    zArg = getArg(z);\r\n  }\r\n\r\n  return new Complex(\r\n    NaN,\r\n    NaN,\r\n    Math.sqrt(zAbs),\r\n    0.5 * zArg,\r\n    mask.HAS_POLAR\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport add from '../methods/add';\r\nimport mul from '../methods/mul';\r\nimport sub from '../methods/sub';\r\nimport from from './from';\r\nimport log from './log';\r\nimport sqrt from './sqrt';\r\nimport square from './square';\r\n\r\nexport default function acos<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const ONE = from(Complex, 1);\r\n  const I = from(Complex, 0, 1);\r\n  const PI_2 = from(Complex, 0.5 * Math.PI);\r\n\r\n  const mul1 = mul(Complex, I, z, i);\r\n  const square1 = square(Complex, z, i);\r\n  const sub1 = sub(Complex, ONE, square1);\r\n  const sqrt1 = sqrt(Complex, sub1);\r\n  const add1 = add(Complex, mul1, sqrt1);\r\n  const log1 = log(Complex, add1);\r\n  const mul2 = mul(Complex, I, log1);\r\n  \r\n  return add(Complex, PI_2, mul2);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport add from '../methods/add';\r\nimport mul from '../methods/mul';\r\nimport from from './from';\r\nimport log from './log';\r\nimport sqrt from './sqrt';\r\n\r\nexport default function acosh<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const ONE = from(Complex, 1);\r\n  const NEG_ONE = from(Complex, -1);\r\n\r\n  const add1 = add(Complex, NEG_ONE, z, i);\r\n  const sqrt1 = sqrt(Complex, add1);\r\n  const add2 = add(Complex, ONE, z, i);\r\n  const sqrt2 = sqrt(Complex, add2);\r\n  const mul1 = mul(Complex, sqrt1, sqrt2);\r\n  const add3 = add(Complex, mul1, z, i);\r\n  \r\n  return log(Complex, add3);\r\n}\r\n","import argImpl from '../internal/argImpl';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getArg from '../methods/getArg';\r\n\r\nexport default function arg<T extends IComplex>(Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const zArg = typeof z === 'number'\r\n    ? argImpl(z, i)\r\n    : getArg(z);\r\n\r\n  return new Complex(\r\n    zArg,\r\n    0,\r\n    Math.abs(zArg),\r\n    zArg < 0 ? Math.PI : 0,\r\n    mask.HAS_ALL\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport add from '../methods/add';\r\nimport mul from '../methods/mul';\r\nimport sub from '../methods/sub';\r\nimport from from './from';\r\nimport log from './log';\r\nimport sqrt from './sqrt';\r\nimport square from './square';\r\n\r\nexport default function asin<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const ONE = from(Complex, 1);\r\n  const I = from(Complex, 0, 1);\r\n  const NEG_I = from(Complex, 0, -1);\r\n\r\n  const mul1 = mul(Complex, I, z, i);\r\n  const square1 = square(Complex, z, i);\r\n  const sub1 = sub(Complex, ONE, square1);\r\n  const sqrt1 = sqrt(Complex, sub1);\r\n  const add1 = add(Complex, mul1, sqrt1);\r\n  const log1 = log(Complex, add1);\r\n  \r\n  return mul(Complex, NEG_I, log1);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport add from '../methods/add';\r\nimport from from './from';\r\nimport log from './log';\r\nimport sqrt from './sqrt';\r\nimport square from './square';\r\n\r\nexport default function asinh<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const ONE = from(Complex, 1);\r\n\r\n  const square1 = square(Complex, z, i);\r\n  const add1 = add(Complex, ONE, square1);\r\n  const sqrt1 = sqrt(Complex, add1);\r\n  const add2 = add(Complex, sqrt1, z, i);\r\n  \r\n  return log(Complex, add2);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport add from '../methods/add';\r\nimport mul from '../methods/mul';\r\nimport sub from '../methods/sub';\r\nimport from from './from';\r\nimport log from './log';\r\n\r\nexport default function atan<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const ONE = from(Complex, 1);\r\n  const I = from(Complex, 0, 1);\r\n  const I_2 = from(Complex, 0, 0.5);\r\n\r\n  const mul1 = mul(Complex, I, z, i);\r\n  const sub1 = sub(Complex, ONE, mul1);\r\n  const log1 = log(Complex, sub1);\r\n  const add1 = add(Complex, ONE, mul1);\r\n  const log2 = log(Complex, add1);\r\n  const sub2 = sub(Complex, log1, log2);\r\n  \r\n  return mul(Complex, I_2, sub2);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport add from '../methods/add';\r\nimport mul from '../methods/mul';\r\nimport sub from '../methods/sub';\r\nimport from from './from';\r\nimport log from './log';\r\n\r\nexport default function atanh<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const ONE = from(Complex, 1);\r\n  const ONE_2 = from(Complex, 0.5);\r\n\r\n  const add1 = add(Complex, ONE, z, i);\r\n  const log1 = log(Complex, add1);\r\n  const sub1 = sub(Complex, ONE, z, i);\r\n  const log2 = log(Complex, sub1);\r\n  const sub2 = sub(Complex, log1, log2);\r\n  \r\n  return mul(Complex, ONE_2, sub2);\r\n}\r\n","import absImpl from '../internal/absImpl';\r\nimport argImpl from '../internal/argImpl';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from '../methods/getAbs';\r\nimport getArg from '../methods/getArg';\r\n\r\nexport default function cbrt<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zAbs: number;\r\n  let zArg: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zAbs = absImpl(z, i);\r\n    zArg = argImpl(z, i);\r\n  } else {\r\n    zAbs = getAbs(z);\r\n    zArg = getArg(z);\r\n  }\r\n\r\n  return new Complex(\r\n    NaN,\r\n    NaN,\r\n    Math.pow(zAbs, 1 / 3),\r\n    zArg / 3,\r\n    mask.HAS_POLAR\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function ceil<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.ceil(zReal), Math.ceil(zImag), NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function conj<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number\r\n  let zImag: number\r\n  let zAbs: number\r\n  let zArg: number\r\n  let zMask: mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n    zAbs = NaN;\r\n    zArg = NaN;\r\n    zMask = mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real;\r\n    zImag = z._imag;\r\n    zAbs = z._abs;\r\n    zArg = z._arg;\r\n    zMask = z._mask;\r\n  }\r\n\r\n  return new Complex(zReal, -zImag, zAbs, -zArg, zMask);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function cos<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zCos = Math.cos(zReal);\r\n\r\n    return new Complex(\r\n      zCos,\r\n      0,\r\n      Math.abs(zCos),\r\n      zCos < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zCos = Math.cosh(zImag);\r\n\r\n    return new Complex(\r\n      zCos,\r\n      0,\r\n      Math.abs(zCos),\r\n      zCos < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  return new Complex(\r\n    Math.cos(zReal) * Math.cosh(zImag),\r\n    Math.sin(zReal) * Math.sinh(zImag),\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function cosh<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zCosh = Math.cosh(zReal);\r\n\r\n    return new Complex(\r\n      zCosh,\r\n      0,\r\n      Math.abs(zCosh),\r\n      zCosh < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zCosh = Math.cos(zImag);\r\n\r\n    return new Complex(\r\n      zCosh,\r\n      0,\r\n      Math.abs(zCosh),\r\n      zCosh < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  return new Complex(\r\n    Math.cosh(zReal) * Math.cos(zImag),\r\n    Math.sinh(zReal) * Math.sin(zImag),\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function exp<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(\r\n    NaN,\r\n    NaN,\r\n    Math.exp(zReal),\r\n    zImag,\r\n    mask.HAS_POLAR\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function floor<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.floor(zReal), Math.floor(zImag), NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport imagImpl from '../internal/imagImpl';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\n\r\nexport default function imag<T extends IComplex>(Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const zImag = typeof z === 'number'\r\n    ? imagImpl(z, i)\r\n    : getImag(z);\r\n\r\n  return new Complex(\r\n    zImag,\r\n    0,\r\n    Math.abs(zImag),\r\n    zImag < 0 ? Math.PI : 0,\r\n    mask.HAS_ALL\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function random<T extends IComplex> (Complex: IComplexConstructor<T>): T {\r\n  return new Complex(Math.random(), Math.random(), NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport realImpl from '../internal/realImpl';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function real<T extends IComplex>(Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  const zReal = typeof z === 'number'\r\n    ? realImpl(z, i)\r\n    : getReal(z);\r\n\r\n  return new Complex(\r\n    zReal,\r\n    0,\r\n    Math.abs(zReal),\r\n    zReal < 0 ? Math.PI : 0,\r\n    mask.HAS_ALL\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function round<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(Math.round(zReal), Math.round(zImag), NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import absImpl from '../internal/absImpl';\r\nimport argImpl from '../internal/argImpl';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getAbs from '../methods/getAbs';\r\nimport getArg from '../methods/getArg';\r\n\r\nexport default function sign<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number\r\n  let zAbs: number;\r\n  let zArg: number;\r\n  let zMask: mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n    zAbs = absImpl(z, i);\r\n    zArg = NaN;\r\n    zMask = mask.HAS_CARTESIAN | mask.HAS_ABS;\r\n  } else {\r\n    zReal = z._real;\r\n    zImag = z._imag;\r\n    zAbs = getAbs(z);\r\n    zArg = z._arg;\r\n    zMask = z._mask;\r\n  }\r\n\r\n  if (zAbs === 0) {\r\n    return new Complex(0, 0, 0, 0, mask.HAS_ALL);\r\n  }\r\n\r\n  if (zAbs !== Infinity) {\r\n    return new Complex(zReal / zAbs, zImag / zAbs, 1, zArg, zMask | mask.HAS_ABS);\r\n  }\r\n\r\n  const zSignArg = typeof z === 'number'\r\n    ? argImpl(zReal, zImag)\r\n    : getArg(z);\r\n\r\n  return new Complex(NaN, NaN, 1, zSignArg, mask.HAS_POLAR);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function sin<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zSin = Math.sin(zReal);\r\n\r\n    return new Complex(\r\n      zSin,\r\n      0,\r\n      Math.abs(zSin),\r\n      zSin < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zSin = Math.sinh(zImag);\r\n\r\n    return new Complex(\r\n      0,\r\n      zSin,\r\n      Math.abs(zSin),\r\n      (zSin < 0 ? -0.5 : 0.5) * Math.PI,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  return new Complex(\r\n    Math.sin(zReal) * Math.cosh(zImag),\r\n    Math.cos(zReal) * Math.sinh(zImag),\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function sinh<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zSinh = Math.sinh(zReal);\r\n\r\n    return new Complex(\r\n      zSinh,\r\n      0,\r\n      Math.abs(zSinh),\r\n      zSinh < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zSinh = Math.sin(zImag);\r\n\r\n    return new Complex(\r\n      0,\r\n      zSinh,\r\n      Math.abs(zSinh),\r\n      (zSinh < 0 ? -0.5 : 0.5) * Math.PI,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  return new Complex(\r\n    Math.sinh(zReal) * Math.cos(zImag),\r\n    Math.cosh(zReal) * Math.sin(zImag),\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function tan<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zTan = Math.sin(2 * zReal) / (Math.cos(2 * zReal) + 1);\r\n\r\n    return new Complex(\r\n      zTan,\r\n      0,\r\n      Math.abs(zTan),\r\n      zTan < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zTan = Math.sinh(2 * zImag) / (1 + Math.cosh(2 * zImag));\r\n\r\n    return new Complex(\r\n      0,\r\n      zTan,\r\n      Math.abs(zTan),\r\n      (zTan < 0 ? -0.5 : 0.5) * Math.PI,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  const zTanDenom = Math.cos(2 * zReal) + Math.cosh(2 * zImag);\r\n\r\n  return new Complex(\r\n    Math.sin(2 * zReal) / zTanDenom,\r\n    Math.sinh(2 * zImag) / zTanDenom,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function tanh<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  if (zImag === 0) {\r\n    const zTanh = Math.sinh(2 * zReal) / (Math.cosh(2 * zReal) + 1);\r\n\r\n    return new Complex(\r\n      zTanh,\r\n      0,\r\n      Math.abs(zTanh),\r\n      zTanh < 0 ? Math.PI : 0,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  if (zReal === 0) {\r\n    const zTanh = Math.sin(2 * zImag) / (1 + Math.cos(2 * zImag));\r\n\r\n    return new Complex(\r\n      0,\r\n      zTanh,\r\n      Math.abs(zTanh),\r\n      (zTanh < 0 ? -0.5 : 0.5) * Math.PI,\r\n      mask.HAS_ALL\r\n    );\r\n  }\r\n\r\n  const zTanhDenom = Math.cosh(2 * zReal) + Math.cos(2 * zImag);\r\n\r\n  return new Complex(\r\n    Math.sinh(2 * zReal) / zTanhDenom,\r\n    Math.sin(2 * zImag) / zTanhDenom,\r\n    NaN,\r\n    NaN,\r\n    mask.HAS_CARTESIAN\r\n  );\r\n}\r\n","import abs from '../functions/abs';\nimport acos from '../functions/acos';\nimport acosh from '../functions/acosh';\nimport arg from '../functions/arg';\nimport asin from '../functions/asin';\nimport asinh from '../functions/asinh';\nimport atan from '../functions/atan';\nimport atanh from '../functions/atanh';\nimport cbrt from '../functions/cbrt';\nimport ceil from '../functions/ceil';\nimport conj from '../functions/conj';\nimport cos from '../functions/cos';\nimport cosh from '../functions/cosh';\nimport cube from '../functions/cube';\nimport exp from '../functions/exp';\nimport floor from '../functions/floor';\nimport imag from '../functions/imag';\nimport log from '../functions/log';\nimport random from '../functions/random';\nimport real from '../functions/real';\nimport round from '../functions/round';\nimport sign from '../functions/sign';\nimport sin from '../functions/sin';\nimport sinh from '../functions/sinh';\nimport sqrt from '../functions/sqrt';\nimport square from '../functions/square';\nimport tan from '../functions/tan';\nimport tanh from '../functions/tanh';\nimport trunc from '../functions/trunc';\n\nexport const callLookup = {\n  abs,\n  acos,\n  acosh,\n  arg,\n  asin,\n  asinh,\n  atan,\n  atanh,\n  cbrt,\n  ceil,\n  conj,\n  cos,\n  cosh,\n  cube,\n  exp,\n  floor,\n  imag,\n  log,\n  random,\n  real,\n  round,\n  sign,\n  sin,\n  sinh,\n  sqrt,\n  square,\n  tan,\n  tanh,\n  trunc\n};\n\nexport type Call = typeof callLookup;\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function neg<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n  let zAbs: number;\r\n  let zArg: number;\r\n  let zMask: mask;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n    zAbs = NaN;\r\n    zArg = NaN;\r\n    zMask = mask.HAS_CARTESIAN;\r\n  } else {\r\n    zReal = z._real;\r\n    zImag = z._imag;\r\n    zAbs = z._abs;\r\n    zArg = z._arg;\r\n    zMask = z._mask;\r\n  }\r\n\r\n  return new Complex(-zReal, -zImag, zAbs, zArg + Math.PI, zMask);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\nimport getImag from '../methods/getImag';\r\nimport getReal from '../methods/getReal';\r\n\r\nexport default function not<T extends IComplex> (Complex: IComplexConstructor<T>, z: IComplex | number, i = 0): T {\r\n  let zReal: number;\r\n  let zImag: number;\r\n\r\n  if (typeof z === 'number') {\r\n    zReal = z;\r\n    zImag = i;\r\n  } else {\r\n    zReal = getReal(z);\r\n    zImag = getImag(z);\r\n  }\r\n\r\n  return new Complex(~zReal, ~zImag, NaN, NaN, mask.HAS_CARTESIAN);\r\n}\r\n","import from from '../functions/from';\r\nimport neg from '../functions/neg';\r\nimport not from '../functions/not';\r\n\r\nexport type Unary = typeof unaryLookup;\r\n\r\nexport const unaryLookup = {\r\n  '+': from,\r\n  '-': neg,\r\n  '~': not\r\n};\r\n","import from from '../functions/from';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport { Binary, binaryLookup } from './binary';\r\nimport { callLookup } from './call';\r\nimport { Unary, unaryLookup } from './unary';\r\n\r\nexport interface IContext<T extends IComplex> {\r\n  [identifierName: string]: T;\r\n}\r\n\r\nexport type Variable<T extends IComplex> = (context: IContext<T>) => T;\r\n\r\ntype Constant<T extends IComplex> = () => T;\r\n\r\nexport type Reviver<T extends IComplex, U extends any[]> = (...args: U) => IContext<T>;\r\n\r\nfunction isConstant<T extends IComplex>(param: Variable<T>): param is Constant<T> {\r\n  return param.length === 0;\r\n}\r\n\r\nfunction areConstant<T extends IComplex>(params: Variable<T>[]): params is Constant<T>[] {\r\n  return params.every(isConstant);\r\n}\r\n\r\nexport type Expression = <T extends IComplex>(Complex: IComplexConstructor<T>) => Variable<T>;\r\n\r\nexport const literal = (data: unknown[]): Expression => {\r\n  const [numericLiteral] = data;\r\n\r\n  return <T extends IComplex>(Complex: IComplexConstructor<T>): Constant<T> => {\r\n    const z = from(Complex, Number(numericLiteral));\r\n\r\n    return (): T => z;\r\n  };\r\n};\r\n\r\nfunction isIndex<T>(key: string | number | symbol, lookup: T): key is keyof T {\r\n  const o = Object(lookup);\r\n  return key in o && o[key] !== undefined;\r\n}\r\n\r\nfunction throwInvalidIdentifierName(name: string): never {\r\n  throw new ReferenceError(`${name} is not defined`);\r\n}\r\n\r\nexport const identifier = (data: unknown[]): Expression => {\r\n  const [identifierName] = data;\r\n  const { text } = identifierName as { text: string };\r\n\r\n  return <T extends IComplex>() => (context: IContext<T>): T => {\r\n    if (!isIndex(text, context)) {\r\n      throwInvalidIdentifierName(text);\r\n    }\r\n\r\n    return context[text];\r\n  };\r\n};\r\n\r\nfunction throwInvalidCallExpression(name: string): never {\r\n  throw new ReferenceError(`${name} is not a function`);\r\n}\r\n\r\nfunction concat<T, U>(t: T, u: U[]): [T, ...U[]] {\r\n  return [t as T | U].concat(u) as [T, ...U[]];\r\n}\r\n\r\nexport const call = (data: unknown[]): Expression => {\r\n  const [identifierName, , expressions] = data;\r\n  const { text } = identifierName as { text: string };\r\n\r\n  if (!isIndex(text, callLookup)) {\r\n    throwInvalidCallExpression(text);\r\n  }\r\n\r\n  return <T extends IComplex>(Complex: IComplexConstructor<T>) => {\r\n    const fn = callLookup[text] as (Complex: IComplexConstructor<T>, ...args: T[]) => T;\r\n    const variables = (expressions as Expression[]).map(expression => expression(Complex));\r\n\r\n    if (areConstant(variables)) {\r\n      const args = concat(\r\n        Complex,\r\n        variables.map(\r\n          constant => constant()\r\n        )\r\n      );\r\n      const z = fn(...args);\r\n\r\n      return () => z;\r\n    }\r\n\r\n    return (context: IContext<T>) => {\r\n      const args = concat(\r\n        Complex,\r\n        variables.map(\r\n          variable => variable(context)\r\n        )\r\n      );\r\n\r\n      return fn(...args);\r\n    };\r\n  };\r\n};\r\n\r\nexport const unary = (data: unknown[]): Expression => {\r\n  const [punctuator, , expression] = data;\r\n\r\n  return Complex => {\r\n    const fn = unaryLookup[punctuator as keyof Unary];\r\n    const variable = (expression as Expression)(Complex);\r\n\r\n    if (isConstant(variable)) {\r\n      const z = fn(Complex, variable());\r\n\r\n      return () => z;\r\n    }\r\n\r\n    return context => fn(Complex, variable(context));\r\n  };\r\n};\r\n\r\nexport const binary = (data: unknown[]): Expression => {\r\n  const [lhsExpression, , punctuator, , rhsExpression] = data;\r\n\r\n  return Complex => {\r\n    const fn = binaryLookup[punctuator as keyof Binary];\r\n    const lhs = (lhsExpression as Expression)(Complex);\r\n    const rhs = (rhsExpression as Expression)(Complex);\r\n\r\n    if (isConstant(lhs) && isConstant(rhs)) {\r\n      const z = fn(Complex, lhs(), rhs());\r\n\r\n      return () => z;\r\n    }\r\n\r\n    return context => fn(Complex, lhs(context), rhs(context));\r\n  };\r\n};\r\n","// Generated automatically by nearley, version 2.19.1\n// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d: any[]): any { return d[0]; }\ndeclare var IdentifierName: any;\ndeclare var DecimalLiteral: any;\ndeclare var BinaryIntegerLiteral: any;\ndeclare var OctalIntegerLiteral: any;\ndeclare var HexIntegerLiteral: any;\ndeclare var WhiteSpace: any;\n\r\nimport moo from 'moo';\r\nimport { literal, identifier, call, unary, binary } from './expressions';\r\n\r\nconst pick = (idx: number) => (data: any[]) => data[idx];\r\nconst empty = () => [];\r\nconst array = (...idx: number[]) => (data: any[]) => idx.map(i => data[i]);\r\nconst reduce = (acc: number, cur: number) => (data: any[]) => data[acc].concat(data[cur]);\r\nconst dispose = () => null;\r\n\r\nconst lexer = moo.compile({\r\n  WhiteSpace: / +/,\r\n  IdentifierName: /[$A-Z_a-z][$\\w]*/,\r\n  DecimalLiteral: /(?:(?:0|[1-9]\\d*)\\.?\\d*|\\.\\d+)(?:[Ee][+-]?\\d+)?/,\r\n  BinaryIntegerLiteral: /0[Bb][01]+/,\r\n  OctalIntegerLiteral: /0[Oo][0-7]+/,\r\n  HexIntegerLiteral: /0[Xx][\\dA-Fa-f]+/,\r\n  // include update punctuators ++ and -- to enforce whitespace between sequential + and - punctuators\r\n  Punctuator: ['(', ')', '[', ']', '.', ',', '+', '-', '*', '/', '%', '**', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '~'],\r\n});\r\n\r\n// use interface declaration merging to resolve type mismatch between nearley NearleyToken and moo Token\r\ninterface NearleyToken {\r\n  offset: number;\r\n  text: string;\r\n  lineBreaks: number;\r\n  line: number;\r\n  col: number;\r\n}\r\n\ninterface NearleyToken {  value: any;\n  [key: string]: any;\n};\n\ninterface NearleyLexer {\n  reset: (chunk: string, info: any) => void;\n  next: () => NearleyToken | undefined;\n  save: () => any;\n  formatError: (token: NearleyToken) => string;\n  has: (tokenType: string) => boolean;\n};\n\ninterface NearleyRule {\n  name: string;\n  symbols: NearleySymbol[];\n  postprocess?: (d: any[], loc?: number, reject?: {}) => any;\n};\n\ntype NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };\n\ninterface Grammar {\n  Lexer: NearleyLexer | undefined;\n  ParserRules: NearleyRule[];\n  ParserStart: string;\n};\n\nconst grammar: Grammar = {\n  Lexer: lexer,\n  ParserRules: [\n    {\"name\": \"Expression\", \"symbols\": [\"_\", \"BitwiseORExpression\", \"_\"], \"postprocess\": pick(1)},\n    {\"name\": \"BitwiseORExpression\", \"symbols\": [\"BitwiseORExpression\", \"_\", {\"literal\":\"|\"}, \"_\", \"BitwiseXORExpression\"], \"postprocess\": binary},\n    {\"name\": \"BitwiseORExpression\", \"symbols\": [\"BitwiseXORExpression\"], \"postprocess\": id},\n    {\"name\": \"BitwiseXORExpression\", \"symbols\": [\"BitwiseXORExpression\", \"_\", {\"literal\":\"^\"}, \"_\", \"BitwiseANDExpression\"], \"postprocess\": binary},\n    {\"name\": \"BitwiseXORExpression\", \"symbols\": [\"BitwiseANDExpression\"], \"postprocess\": id},\n    {\"name\": \"BitwiseANDExpression\", \"symbols\": [\"BitwiseANDExpression\", \"_\", {\"literal\":\"&\"}, \"_\", \"ShiftExpression\"], \"postprocess\": binary},\n    {\"name\": \"BitwiseANDExpression\", \"symbols\": [\"ShiftExpression\"], \"postprocess\": id},\n    {\"name\": \"ShiftExpression\", \"symbols\": [\"ShiftExpression\", \"_\", \"ShiftOperator\", \"_\", \"AdditiveExpression\"], \"postprocess\": binary},\n    {\"name\": \"ShiftExpression\", \"symbols\": [\"AdditiveExpression\"], \"postprocess\": id},\n    {\"name\": \"ShiftOperator\", \"symbols\": [{\"literal\":\"<<\"}], \"postprocess\": id},\n    {\"name\": \"ShiftOperator\", \"symbols\": [{\"literal\":\">>\"}], \"postprocess\": id},\n    {\"name\": \"ShiftOperator\", \"symbols\": [{\"literal\":\">>>\"}], \"postprocess\": id},\n    {\"name\": \"AdditiveExpression\", \"symbols\": [\"AdditiveExpression\", \"_\", \"AdditiveOperator\", \"_\", \"MultiplicativeExpression\"], \"postprocess\": binary},\n    {\"name\": \"AdditiveExpression\", \"symbols\": [\"MultiplicativeExpression\"], \"postprocess\": id},\n    {\"name\": \"AdditiveOperator\", \"symbols\": [{\"literal\":\"+\"}], \"postprocess\": id},\n    {\"name\": \"AdditiveOperator\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"MultiplicativeExpression\", \"symbols\": [\"MultiplicativeExpression\", \"_\", \"MultiplicativeOperator\", \"_\", \"ExponentiationExpression\"], \"postprocess\": binary},\n    {\"name\": \"MultiplicativeExpression\", \"symbols\": [\"ExponentiationExpression\"], \"postprocess\": id},\n    {\"name\": \"MultiplicativeOperator\", \"symbols\": [{\"literal\":\"*\"}], \"postprocess\": id},\n    {\"name\": \"MultiplicativeOperator\", \"symbols\": [{\"literal\":\"/\"}], \"postprocess\": id},\n    {\"name\": \"MultiplicativeOperator\", \"symbols\": [{\"literal\":\"%\"}], \"postprocess\": id},\n    {\"name\": \"ExponentiationExpression\", \"symbols\": [\"LeftHandSideExpression\", \"_\", {\"literal\":\"**\"}, \"_\", \"ExponentiationExpression\"], \"postprocess\": binary},\n    {\"name\": \"ExponentiationExpression\", \"symbols\": [\"UnaryExpression\"], \"postprocess\": id},\n    {\"name\": \"UnaryExpression\", \"symbols\": [\"UnaryOperator\", \"_\", \"UnaryExpression\"], \"postprocess\": unary},\n    {\"name\": \"UnaryExpression\", \"symbols\": [\"LeftHandSideExpression\"], \"postprocess\": id},\n    {\"name\": \"UnaryOperator\", \"symbols\": [{\"literal\":\"+\"}], \"postprocess\": id},\n    {\"name\": \"UnaryOperator\", \"symbols\": [{\"literal\":\"-\"}], \"postprocess\": id},\n    {\"name\": \"UnaryOperator\", \"symbols\": [{\"literal\":\"~\"}], \"postprocess\": id},\n    {\"name\": \"LeftHandSideExpression\", \"symbols\": [\"ParenthesizedExpression\"], \"postprocess\": id},\n    {\"name\": \"LeftHandSideExpression\", \"symbols\": [\"PrimaryExpression\"], \"postprocess\": id},\n    {\"name\": \"ParenthesizedExpression\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"BitwiseORExpression\", \"_\", {\"literal\":\")\"}], \"postprocess\": pick(2)},\n    {\"name\": \"ParenthesizedExpression\", \"symbols\": [{\"literal\":\"[\"}, \"_\", \"BitwiseORExpression\", \"_\", {\"literal\":\"]\"}], \"postprocess\": pick(2)},\n    {\"name\": \"PrimaryExpression\", \"symbols\": [\"CallExpression\"], \"postprocess\": id},\n    {\"name\": \"PrimaryExpression\", \"symbols\": [(lexer.has(\"IdentifierName\") ? {type: \"IdentifierName\"} : IdentifierName)], \"postprocess\": identifier},\n    {\"name\": \"PrimaryExpression\", \"symbols\": [\"NumericLiteral\"], \"postprocess\": literal},\n    {\"name\": \"NumericLiteral\", \"symbols\": [(lexer.has(\"DecimalLiteral\") ? {type: \"DecimalLiteral\"} : DecimalLiteral)], \"postprocess\": id},\n    {\"name\": \"NumericLiteral\", \"symbols\": [(lexer.has(\"BinaryIntegerLiteral\") ? {type: \"BinaryIntegerLiteral\"} : BinaryIntegerLiteral)], \"postprocess\": id},\n    {\"name\": \"NumericLiteral\", \"symbols\": [(lexer.has(\"OctalIntegerLiteral\") ? {type: \"OctalIntegerLiteral\"} : OctalIntegerLiteral)], \"postprocess\": id},\n    {\"name\": \"NumericLiteral\", \"symbols\": [(lexer.has(\"HexIntegerLiteral\") ? {type: \"HexIntegerLiteral\"} : HexIntegerLiteral)], \"postprocess\": id},\n    {\"name\": \"CallExpression\", \"symbols\": [(lexer.has(\"IdentifierName\") ? {type: \"IdentifierName\"} : IdentifierName), \"_\", \"Arguments\"], \"postprocess\": call},\n    {\"name\": \"Arguments\", \"symbols\": [{\"literal\":\"(\"}, \"_\", \"ArgumentList\", \"_\", {\"literal\":\")\"}], \"postprocess\": pick(2)},\n    {\"name\": \"Arguments\", \"symbols\": [{\"literal\":\"(\"}, \"_\", {\"literal\":\")\"}], \"postprocess\": empty},\n    {\"name\": \"ArgumentList\", \"symbols\": [\"ArgumentList\", \"_\", {\"literal\":\",\"}, \"_\", \"BitwiseORExpression\"], \"postprocess\": reduce(0, 4)},\n    {\"name\": \"ArgumentList\", \"symbols\": [\"BitwiseORExpression\"], \"postprocess\": array(0)},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [(lexer.has(\"WhiteSpace\") ? {type: \"WhiteSpace\"} : WhiteSpace)], \"postprocess\": id},\n    {\"name\": \"_$ebnf$1\", \"symbols\": [], \"postprocess\": () => null},\n    {\"name\": \"_\", \"symbols\": [\"_$ebnf$1\"], \"postprocess\": dispose}\n  ],\n  ParserStart: \"Expression\",\n};\n\nexport default grammar;\n","import { Grammar, Parser } from 'nearley';\r\nimport { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport { Expression, Variable } from './expressions';\r\nimport grammar from './grammar';\r\n\r\nconst rules = Grammar.fromCompiled(grammar);\r\n\r\nexport default function generate<T extends IComplex>(Complex: IComplexConstructor<T>, text: string): Variable<T> {\r\n  const parser = new Parser(rules);\r\n  const { results } = parser.feed(text);\r\n\r\n  switch (results.length) {\r\n    case 0:\r\n      throw new Error('Unexpected end of input');\r\n    case 1:\r\n      const [expression]: Expression[] = results;\r\n      return expression(Complex);\r\n    default:\r\n      throw new Error('Ambiguous grammar');\r\n  }\r\n}\r\n","import { IComplex } from '../internal/complex';\r\nimport getAbs from './getAbs';\r\nimport getArg from './getArg';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\ntype Coordinates = 'c' | 'p';\r\ntype Radix = 'X' | 'x' | 'o' | 'b' | '';\r\ntype Specifier = 'r' | 'i' | 'm' | 'a';\r\ninterface IFormat {\r\n  minus: boolean;\r\n  plus: boolean;\r\n  pound: boolean;\r\n  precision: number | '';\r\n  radix: Radix;\r\n  specifier: Specifier;\r\n  width: number;\r\n  zero: boolean;\r\n}\r\n\r\nconst fmtCoord = /%([cp])/g;\r\nconst fmtParts = /%([#0+-]{0,4})(\\d{0,2})((?:\\.\\d{0,2})?)([Xxob]?)([rima])/g;\r\n\r\nexport default function toString (z: IComplex, format = '%c'): string {\r\n  return format\r\n    .replace(fmtCoord, replaceCoord)\r\n    .replace(fmtParts, replaceParts(z));\r\n}\r\n\r\nfunction replaceCoord (_: string, coord: Coordinates): string {\r\n  switch (coord) {\r\n    case 'c': return '%r%+i*i';\r\n    case 'p': return '%m*e**(%a*i)';\r\n  }\r\n}\r\n\r\nfunction replaceParts (z: IComplex): (...args: string[]) => string {\r\n  return (_, flag, width, precision, radix, specifier) => {\r\n    return stringify(z, {\r\n      minus: flag.includes('-'),\r\n      plus: flag.includes('+'),\r\n      pound: flag.includes('#'),\r\n      precision: precision && +precision.slice(1),\r\n      radix: radix as Radix,\r\n      specifier: specifier as Specifier,\r\n      width: +width,\r\n      zero: flag.includes('0')\r\n    });\r\n  };\r\n}\r\n\r\nfunction stringify (z: IComplex, format: IFormat): string {\r\n  return width(precision(radix(specifier())));\r\n\r\n  function specifier (): number {\r\n    switch (format.specifier) {\r\n      case 'r': return getReal(z);\r\n      case 'i': return getImag(z);\r\n      case 'm': return getAbs(z);\r\n      case 'a': return getArg(z);\r\n    }\r\n  }\r\n\r\n  function radix (num: number): string {\r\n    switch (format.radix) {\r\n      case 'X': return num.toString(16).toUpperCase();\r\n      case 'x': return num.toString(16).toLowerCase();\r\n      case 'o': return num.toString(8);\r\n      case 'b': return num.toString(2);\r\n      case '': return num.toString(10);\r\n    }\r\n  }\r\n\r\n  function precision (str: string): string {\r\n    const target = format.precision;\r\n    const index = str.indexOf('.') + 1;\r\n\r\n    if (target === '') return str;\r\n\r\n    if (index === 0) {\r\n      if (target === 0) return str;\r\n\r\n      return `${str}.${'0'.repeat(target)}`;\r\n    }\r\n\r\n    const digits = str.length - index;\r\n    const remove = Math.max(digits - target, 0);\r\n    const insert = Math.max(target - digits, 0);\r\n\r\n    return str.slice(0, str.length - remove) + '0'.repeat(insert);\r\n  }\r\n\r\n  function width (str: string): string {\r\n    if (format.minus) {\r\n      return plus(pound(str)).padEnd(format.width, ' ');\r\n    }\r\n\r\n    if (!format.zero) {\r\n      return plus(pound(str)).padStart(format.width, ' ');\r\n    }\r\n\r\n    if (!str.startsWith('-')) {\r\n      return plus(pound(str.padStart(format.width, '0')));\r\n    }\r\n\r\n    return plus(pound(`-${str.slice(1).padStart(format.width - 1, '0')}`));\r\n  }\r\n\r\n  function plus (str: string) {\r\n    if (!format.plus || str.startsWith('-')) {\r\n      return str;\r\n    }\r\n\r\n    return `+${str}`;\r\n  }\r\n\r\n  function pound (str: string): string {\r\n    if (!format.pound || !format.radix) {\r\n      return str;\r\n    }\r\n\r\n    const base = `0${format.radix}`;\r\n\r\n    if (!str.startsWith('-')) {\r\n      return base + str;\r\n    }\r\n\r\n    return `-${base + str.slice(1)}`;\r\n  }\r\n}\r\n","import compile from './compiler/compile';\r\nimport parse from './compiler/parse';\r\nimport abs from './functions/abs';\r\nimport acos from './functions/acos';\r\nimport acosh from './functions/acosh';\r\nimport arg from './functions/arg';\r\nimport asin from './functions/asin';\r\nimport asinh from './functions/asinh';\r\nimport atan from './functions/atan';\r\nimport atanh from './functions/atanh';\r\nimport cbrt from './functions/cbrt';\r\nimport ceil from './functions/ceil';\r\nimport conj from './functions/conj';\r\nimport cos from './functions/cos';\r\nimport cosh from './functions/cosh';\r\nimport cube from './functions/cube';\r\nimport exp from './functions/exp';\r\nimport floor from './functions/floor';\r\nimport from from './functions/from';\r\nimport imag from './functions/imag';\r\nimport log from './functions/log';\r\nimport neg from './functions/neg';\r\nimport not from './functions/not';\r\nimport polar from './functions/polar';\r\nimport random from './functions/random';\r\nimport real from './functions/real';\r\nimport round from './functions/round';\r\nimport sign from './functions/sign';\r\nimport sin from './functions/sin';\r\nimport sinh from './functions/sinh';\r\nimport sqrt from './functions/sqrt';\r\nimport square from './functions/square';\r\nimport tan from './functions/tan';\r\nimport tanh from './functions/tanh';\r\nimport trunc from './functions/trunc';\r\nimport mask from './internal/mask';\r\nimport add from './methods/add';\r\nimport and from './methods/and';\r\nimport div from './methods/div';\r\nimport equals from './methods/equals';\r\nimport getAbs from './methods/getAbs';\r\nimport getArg from './methods/getArg';\r\nimport getImag from './methods/getImag';\r\nimport getReal from './methods/getReal';\r\nimport mod from './methods/mod';\r\nimport mul from './methods/mul';\r\nimport or from './methods/or';\r\nimport pow from './methods/pow';\r\nimport sal from './methods/sal';\r\nimport sar from './methods/sar';\r\nimport shr from './methods/shr';\r\nimport sub from './methods/sub';\r\nimport toString from './methods/toString';\r\nimport xor from './methods/xor';\r\n\r\nexport interface IContext {\r\n  [identifierName: string]: Complex;\r\n}\r\n\r\nexport type IReviver<T extends any[]> = (...args: T) => IContext;\r\n\r\nexport default class Complex {\r\n  public static readonly '0' = Complex.from(0);\r\n  public static readonly '1' = Complex.from(1);\r\n  public static readonly 'I' = Complex.from(0, 1);\r\n  public static readonly 'E' = Complex.from(Math.E);\r\n  public static readonly 'LN2' = Complex.from(Math.LN2);\r\n  public static readonly 'LN10' = Complex.from(Math.LN10);\r\n  public static readonly 'LOG2E' = Complex.from(Math.LOG2E);\r\n  public static readonly 'LOG10E' = Complex.from(Math.LOG10E);\r\n  public static readonly 'PI' = Complex.from(Math.PI);\r\n  public static readonly 'SQRT1_2' = Complex.from(Math.SQRT1_2);\r\n  public static readonly 'SQRT2' = Complex.from(Math.SQRT2);\r\n\r\n  public static from (r: number, i?: number): Complex;\r\n  public static from (z: Complex | number): Complex;\r\n  public static from (z: Complex | number, i?: number): Complex {\r\n    return from(Complex, z, i);\r\n  }\r\n\r\n  public static cartesian (r: number, i = 0): Complex {\r\n    return new Complex(r, i, NaN, NaN, mask.HAS_CARTESIAN);\r\n  }\r\n\r\n  public static polar (abs: number, arg?: number): Complex {\r\n    return polar(Complex, abs, arg);\r\n  }\r\n\r\n  public static real (z: Complex | number): Complex;\r\n  public static real (r: number, i?: number): Complex;\r\n  public static real (z: Complex | number, i?: number): Complex {\r\n    return real(Complex, z, i);\r\n  }\r\n\r\n  public static imag (z: Complex | number): Complex;\r\n  public static imag (r: number, i?: number): Complex;\r\n  public static imag (z: Complex | number, i?: number): Complex {\r\n    return imag(Complex, z, i);\r\n  }\r\n\r\n  public static abs (z: Complex | number): Complex;\r\n  public static abs (r: number, i?: number): Complex;\r\n  public static abs (z: Complex | number, i?: number): Complex {\r\n    return abs(Complex, z, i);\r\n  }\r\n\r\n  public static arg (z: Complex | number): Complex;\r\n  public static arg (r: number, i?: number): Complex;\r\n  public static arg (z: Complex | number, i?: number): Complex {\r\n    return arg(Complex, z, i);\r\n  }\r\n\r\n  public static neg (z: Complex | number): Complex;\r\n  public static neg (r: number, i?: number): Complex;\r\n  public static neg (z: Complex | number, i?: number): Complex {\r\n    return neg(Complex, z, i);\r\n  }\r\n\r\n  public static conj (z: Complex | number): Complex;\r\n  public static conj (r: number, i?: number): Complex;\r\n  public static conj (z: Complex | number, i?: number): Complex {\r\n    return conj(Complex, z, i);\r\n  }\r\n\r\n  public static floor (z: Complex | number): Complex;\r\n  public static floor (r: number, i?: number): Complex;\r\n  public static floor (z: Complex | number, i?: number): Complex {\r\n    return floor(Complex, z, i);\r\n  }\r\n\r\n  public static ceil (z: Complex | number): Complex;\r\n  public static ceil (r: number, i?: number): Complex;\r\n  public static ceil (z: Complex | number, i?: number): Complex {\r\n    return ceil(Complex, z, i);\r\n  }\r\n\r\n  public static round (z: Complex | number): Complex;\r\n  public static round (r: number, i?: number): Complex;\r\n  public static round (z: Complex | number, i?: number): Complex {\r\n    return round(Complex, z, i);\r\n  }\r\n\r\n  public static sign (z: Complex | number): Complex;\r\n  public static sign (r: number, i?: number): Complex;\r\n  public static sign (z: Complex | number, i?: number): Complex {\r\n    return sign(Complex, z, i);\r\n  }\r\n\r\n  public static trunc (z: Complex | number): Complex;\r\n  public static trunc (r: number, i?: number): Complex;\r\n  public static trunc (z: Complex | number, i?: number): Complex {\r\n    return trunc(Complex, z, i);\r\n  }\r\n\r\n  public static not (z: Complex | number): Complex;\r\n  public static not (r: number, i?: number): Complex;\r\n  public static not (z: Complex | number, i?: number): Complex {\r\n    return not(Complex, z, i);\r\n  }\r\n\r\n  public static random (): Complex {\r\n    return random(Complex);\r\n  }\r\n\r\n  public static sqrt (z: Complex | number): Complex;\r\n  public static sqrt (r: number, i?: number): Complex;\r\n  public static sqrt (z: Complex | number, i?: number): Complex {\r\n    return sqrt(Complex, z, i);\r\n  }\r\n\r\n  public static cbrt (z: Complex | number): Complex;\r\n  public static cbrt (r: number, i?: number): Complex;\r\n  public static cbrt (z: Complex | number, i?: number): Complex {\r\n    return cbrt(Complex, z, i);\r\n  }\r\n\r\n  public static square (z: Complex | number): Complex;\r\n  public static square (r: number, i?: number): Complex;\r\n  public static square (z: Complex | number, i?: number): Complex {\r\n    return square(Complex, z, i);\r\n  }\r\n\r\n  public static cube (z: Complex | number): Complex;\r\n  public static cube (r: number, i?: number): Complex;\r\n  public static cube (z: Complex | number, i?: number): Complex {\r\n    return cube(Complex, z, i);\r\n  }\r\n\r\n  public static exp (z: Complex | number): Complex;\r\n  public static exp (r: number, i?: number): Complex;\r\n  public static exp (z: Complex | number, i?: number): Complex {\r\n    return exp(Complex, z, i);\r\n  }\r\n\r\n  public static log (z: Complex | number): Complex;\r\n  public static log (r: number, i?: number): Complex;\r\n  public static log (z: Complex | number, i?: number): Complex {\r\n    return log(Complex, z, i);\r\n  }\r\n\r\n  public static cos (z: Complex | number): Complex;\r\n  public static cos (r: number, i?: number): Complex;\r\n  public static cos (z: Complex | number, i?: number): Complex {\r\n    return cos(Complex, z, i);\r\n  }\r\n\r\n  public static sin (z: Complex | number): Complex;\r\n  public static sin (r: number, i?: number): Complex;\r\n  public static sin (z: Complex | number, i?: number): Complex {\r\n    return sin(Complex, z, i);\r\n  }\r\n\r\n  public static tan (z: Complex | number): Complex;\r\n  public static tan (r: number, i?: number): Complex;\r\n  public static tan (z: Complex | number, i?: number): Complex {\r\n    return tan(Complex, z, i);\r\n  }\r\n\r\n  public static acos (z: Complex | number): Complex;\r\n  public static acos (r: number, i?: number): Complex;\r\n  public static acos (z: Complex | number, i?: number): Complex {\r\n    return acos(Complex, z, i);\r\n  }\r\n\r\n  public static asin (z: Complex | number): Complex;\r\n  public static asin (r: number, i?: number): Complex;\r\n  public static asin (z: Complex | number, i?: number): Complex {\r\n    return asin(Complex, z, i);\r\n  }\r\n\r\n  public static atan (z: Complex | number): Complex;\r\n  public static atan (r: number, i?: number): Complex;\r\n  public static atan (z: Complex | number, i?: number): Complex {\r\n    return atan(Complex, z, i);\r\n  }\r\n\r\n  public static cosh (z: Complex | number): Complex;\r\n  public static cosh (r: number, i?: number): Complex;\r\n  public static cosh (z: Complex | number, i?: number): Complex {\r\n    return cosh(Complex, z, i);\r\n  }\r\n\r\n  public static sinh (z: Complex | number): Complex;\r\n  public static sinh (r: number, i?: number): Complex;\r\n  public static sinh (z: Complex | number, i?: number): Complex {\r\n    return sinh(Complex, z, i);\r\n  }\r\n\r\n  public static tanh (z: Complex | number): Complex;\r\n  public static tanh (r: number, i?: number): Complex;\r\n  public static tanh (z: Complex | number, i?: number): Complex {\r\n    return tanh(Complex, z, i);\r\n  }\r\n\r\n  public static acosh (z: Complex | number): Complex;\r\n  public static acosh (r: number, i?: number): Complex;\r\n  public static acosh (z: Complex | number, i?: number): Complex {\r\n    return acosh(Complex, z, i);\r\n  }\r\n\r\n  public static asinh (z: Complex | number): Complex;\r\n  public static asinh (r: number, i?: number): Complex;\r\n  public static asinh (z: Complex | number, i?: number): Complex {\r\n    return asinh(Complex, z, i);\r\n  }\r\n\r\n  public static atanh (z: Complex | number): Complex;\r\n  public static atanh (r: number, i?: number): Complex;\r\n  public static atanh (z: Complex | number, i?: number): Complex {\r\n    return atanh(Complex, z, i);\r\n  }\r\n\r\n  public static parse (text: string, context?: IContext): Complex {\r\n    return parse(Complex, text, context);\r\n  }\r\n\r\n  public static compile (text: string): () => Complex;\r\n  public static compile<T extends any[]> (text: string, reviver: IReviver<T>): (...args: T) => Complex;\r\n  public static compile<T extends any[]> (text: string, reviver?: IReviver<T>): (...args: T) => Complex {\r\n    return compile(Complex, text, reviver);\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public _real: number;\r\n  /**\r\n   * @internal\r\n   */\r\n  public _imag: number;\r\n  /**\r\n   * @internal\r\n   */\r\n  public _abs: number;\r\n  /**\r\n   * @internal\r\n   */\r\n  public _arg: number;\r\n  /**\r\n   * @internal\r\n   */\r\n  public _mask: mask;\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public constructor (_real: number, _imag: number, _abs: number, _arg: number, _mask: mask) {\r\n    // coerce -0 to +0\r\n    this._real = _real + 0;\r\n    this._imag = _imag + 0;\r\n    this._abs = _abs + 0;\r\n    // choose branch cut as the interval (-pi, pi]\r\n    this._arg = Math.PI - ((Math.PI - _arg) % (Math.PI * 2));\r\n    this._mask = _mask;\r\n  }\r\n\r\n  public get real (): number {\r\n    return getReal(this);\r\n  }\r\n\r\n  public get imag (): number {\r\n    return getImag(this);\r\n  }\r\n\r\n  public get abs (): number {\r\n    return getAbs(this);\r\n  }\r\n\r\n  public get arg (): number {\r\n    return getArg(this);\r\n  }\r\n\r\n  public toString (format?: string): string {\r\n    return toString(this, format);\r\n  }\r\n\r\n  public equals (rhs: Complex | number): boolean;\r\n  public equals (r: number, i?: number): boolean;\r\n  public equals (r: Complex | number, i?: number): boolean {\r\n    return equals(this, r, i);\r\n  }\r\n\r\n  public add (rhs: Complex | number): Complex;\r\n  public add (r: number, i?: number): Complex;\r\n  public add (r: Complex | number, i?: number): Complex {\r\n    return add(Complex, this, r, i);\r\n  }\r\n\r\n  public sub (rhs: Complex | number): Complex;\r\n  public sub (r: number, i?: number): Complex;\r\n  public sub (r: Complex | number, i?: number): Complex {\r\n    return sub(Complex, this, r, i);\r\n  }\r\n\r\n  public mul (rhs: Complex | number): Complex;\r\n  public mul (r: number, i?: number): Complex;\r\n  public mul (r: Complex | number, i?: number): Complex {\r\n    return mul(Complex, this, r, i);\r\n  }\r\n\r\n  public div (rhs: Complex | number): Complex;\r\n  public div (r: number, i?: number): Complex;\r\n  public div (r: Complex | number, i?: number): Complex {\r\n    return div(Complex, this, r, i);\r\n  }\r\n\r\n  public mod (rhs: Complex | number): Complex;\r\n  public mod (r: number, i?: number): Complex;\r\n  public mod (r: Complex | number, i?: number): Complex {\r\n    return mod(Complex, this, r, i);\r\n  }\r\n\r\n  public pow (rhs: Complex | number): Complex;\r\n  public pow (r: number, i?: number): Complex;\r\n  public pow (r: Complex | number, i?: number): Complex {\r\n    return pow(Complex, this, r, i);\r\n  }\r\n\r\n  public and (rhs: Complex | number): Complex;\r\n  public and (r: number, i?: number): Complex;\r\n  public and (r: Complex | number, i?: number): Complex {\r\n    return and(Complex, this, r, i);\r\n  }\r\n\r\n  public or (rhs: Complex | number): Complex;\r\n  public or (r: number, i?: number): Complex;\r\n  public or (r: Complex | number, i?: number): Complex {\r\n    return or(Complex, this, r, i);\r\n  }\r\n\r\n  public xor (rhs: Complex | number): Complex;\r\n  public xor (r: number, i?: number): Complex;\r\n  public xor (r: Complex | number, i?: number): Complex {\r\n    return xor(Complex, this, r, i);\r\n  }\r\n\r\n  public sal (rhs: Complex | number): Complex;\r\n  public sal (r: number, i?: number): Complex;\r\n  public sal (r: Complex | number, i?: number): Complex {\r\n    return sal(Complex, this, r, i);\r\n  }\r\n  public shl (rhs: Complex | number): Complex;\r\n  public shl (r: number, i?: number): Complex;\r\n  public shl (r: Complex | number, i?: number): Complex {\r\n    return sal(Complex, this, r, i);\r\n  }\r\n\r\n  public sar (rhs: Complex | number): Complex;\r\n  public sar (r: number, i?: number): Complex;\r\n  public sar (r: Complex | number, i?: number): Complex {\r\n    return sar(Complex, this, r, i);\r\n  }\r\n\r\n  public shr (rhs: Complex | number): Complex;\r\n  public shr (r: number, i?: number): Complex;\r\n  public shr (r: Complex | number, i?: number): Complex {\r\n    return shr(Complex, this, r, i);\r\n  }\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport mask from '../internal/mask';\r\n\r\nexport default function polar<T extends IComplex> (Complex: IComplexConstructor<T>, abs: number, arg = 0): T {\r\n  let zAbs: number;\r\n  let zArg: number;\r\n\r\n  if (abs < 0) {\r\n    zAbs = -abs;\r\n    zArg = arg + Math.PI;\r\n  } else {\r\n    zAbs = abs;\r\n    zArg = arg;\r\n  }\r\n\r\n  return new Complex(NaN, NaN, zAbs, zArg, mask.HAS_POLAR);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport { IContext } from './expressions';\r\nimport generate from './generate';\r\n\r\nexport default function parse<T extends IComplex>(Complex: IComplexConstructor<T>, text: string, context?: IContext<T>): T {\r\n  const variable = generate(Complex, text);\r\n\r\n  return variable(context!);\r\n}\r\n","import { IComplex, IComplexConstructor } from '../internal/complex';\r\nimport { Reviver } from './expressions';\r\nimport generate from './generate';\r\n\r\nexport default function compile<T extends IComplex, U extends any[]>(\r\n  Complex: IComplexConstructor<T>,\r\n  text: string,\r\n  reviver?: Reviver<T, U>\r\n): (...args: U) => T {\r\n  const variable = generate(Complex, text);\r\n\r\n  if (reviver) {\r\n    return (...args): T => variable(reviver(...args));\r\n  }\r\n\r\n  const z = variable({});\r\n\r\n  return () => z;\r\n}\r\n","import { IComplex } from '../internal/complex';\r\nimport getImag from './getImag';\r\nimport getReal from './getReal';\r\n\r\nexport default function equals (lhs: IComplex, r: IComplex | number, i = 0): boolean {\r\n  let rhsReal: number;\r\n  let rhsImag: number;\r\n\r\n  if (typeof r === 'number') {\r\n    rhsReal = r;\r\n    rhsImag = i;\r\n  } else {\r\n    rhsReal = getReal(r);\r\n    rhsImag = getImag(r);\r\n  }\r\n\r\n  const lhsReal = getReal(lhs);\r\n  const lhsImag = getImag(lhs);\r\n\r\n  return lhsReal === rhsReal && lhsImag === rhsImag;\r\n}\r\n"],"names":["from","Complex","z","i","zReal","zImag","zAbs","zArg","zMask","NaN","_real","_imag","_abs","_arg","_mask","imagImpl","abs","arg","Math","PI","sin","getImag","realImpl","cos","getReal","add","lhs","r","rhsReal","rhsImag","and","absImpl","real","imag","hypot","getAbs","argImpl","atan2","getArg","div","rhsAbs2","rhs","trunc","mul","sub","mod","or","cube","real2","imag2","square","pow","c","d","m","a","exp","log","sal","sar","shr","xor","binaryLookup","%","&","*","**","+","-","/","<<",">>",">>>","^","|","sqrt","acos","ONE","I","PI_2","add1","acosh","sqrt1","add2","asin","NEG_I","mul1","asinh","atan","I_2","sub1","atanh","ONE_2","log1","cbrt","ceil","conj","zCos","cosh","sinh","zCosh","floor","random","round","sign","Infinity","zSin","zSinh","tan","zTan","zTanDenom","tanh","zTanh","zTanhDenom","callLookup","neg","not","unaryLookup","~","isConstant","param","length","isIndex","key","lookup","o","Object","undefined","concat","t","u","binary","data","lhsExpression","punctuator","rhsExpression","fn","z_3","context","id","acc","cur","pick","idx","lexer","moo","compile","WhiteSpace","IdentifierName","DecimalLiteral","BinaryIntegerLiteral","OctalIntegerLiteral","HexIntegerLiteral","Punctuator","grammar","Lexer","ParserRules","name","symbols","postprocess","literal","expression","variable","z_2","has","type","text","ReferenceError","throwInvalidIdentifierName","numericLiteral","Number","identifierName","expressions","throwInvalidCallExpression","variables","map","every","args","constant","z_1","_i","array","ParserStart","rules","Grammar","fromCompiled","generate","results","Parser","Error","fmtCoord","fmtParts","toString","format","replace","replaceCoord","_","flag","width","precision","radix","specifier","str","minus","plus","pound","padEnd","zero","padStart","startsWith","slice","target","index","indexOf","repeat","digits","remove","max","insert","num","toUpperCase","toLowerCase","base","stringify","includes","replaceParts","coord","this","polar","parse","reviver","lhsReal","lhsImag","equals","E","LN2","LN10","LOG2E","LOG10E","SQRT1_2","SQRT2"],"mappings":"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"}