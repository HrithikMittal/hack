interface IContext {
    [identifierName: string]: Complex;
}
declare type IReviver<T extends any[]> = (...args: T) => IContext;
declare class Complex {
    static readonly '0': Complex;
    static readonly '1': Complex;
    static readonly 'I': Complex;
    static readonly 'E': Complex;
    static readonly 'LN2': Complex;
    static readonly 'LN10': Complex;
    static readonly 'LOG2E': Complex;
    static readonly 'LOG10E': Complex;
    static readonly 'PI': Complex;
    static readonly 'SQRT1_2': Complex;
    static readonly 'SQRT2': Complex;
    static from(r: number, i?: number): Complex;
    static from(z: Complex | number): Complex;
    static cartesian(r: number, i?: number): Complex;
    static polar(abs: number, arg?: number): Complex;
    static real(z: Complex | number): Complex;
    static real(r: number, i?: number): Complex;
    static imag(z: Complex | number): Complex;
    static imag(r: number, i?: number): Complex;
    static abs(z: Complex | number): Complex;
    static abs(r: number, i?: number): Complex;
    static arg(z: Complex | number): Complex;
    static arg(r: number, i?: number): Complex;
    static neg(z: Complex | number): Complex;
    static neg(r: number, i?: number): Complex;
    static conj(z: Complex | number): Complex;
    static conj(r: number, i?: number): Complex;
    static floor(z: Complex | number): Complex;
    static floor(r: number, i?: number): Complex;
    static ceil(z: Complex | number): Complex;
    static ceil(r: number, i?: number): Complex;
    static round(z: Complex | number): Complex;
    static round(r: number, i?: number): Complex;
    static sign(z: Complex | number): Complex;
    static sign(r: number, i?: number): Complex;
    static trunc(z: Complex | number): Complex;
    static trunc(r: number, i?: number): Complex;
    static not(z: Complex | number): Complex;
    static not(r: number, i?: number): Complex;
    static random(): Complex;
    static sqrt(z: Complex | number): Complex;
    static sqrt(r: number, i?: number): Complex;
    static cbrt(z: Complex | number): Complex;
    static cbrt(r: number, i?: number): Complex;
    static square(z: Complex | number): Complex;
    static square(r: number, i?: number): Complex;
    static cube(z: Complex | number): Complex;
    static cube(r: number, i?: number): Complex;
    static exp(z: Complex | number): Complex;
    static exp(r: number, i?: number): Complex;
    static log(z: Complex | number): Complex;
    static log(r: number, i?: number): Complex;
    static cos(z: Complex | number): Complex;
    static cos(r: number, i?: number): Complex;
    static sin(z: Complex | number): Complex;
    static sin(r: number, i?: number): Complex;
    static tan(z: Complex | number): Complex;
    static tan(r: number, i?: number): Complex;
    static acos(z: Complex | number): Complex;
    static acos(r: number, i?: number): Complex;
    static asin(z: Complex | number): Complex;
    static asin(r: number, i?: number): Complex;
    static atan(z: Complex | number): Complex;
    static atan(r: number, i?: number): Complex;
    static cosh(z: Complex | number): Complex;
    static cosh(r: number, i?: number): Complex;
    static sinh(z: Complex | number): Complex;
    static sinh(r: number, i?: number): Complex;
    static tanh(z: Complex | number): Complex;
    static tanh(r: number, i?: number): Complex;
    static acosh(z: Complex | number): Complex;
    static acosh(r: number, i?: number): Complex;
    static asinh(z: Complex | number): Complex;
    static asinh(r: number, i?: number): Complex;
    static atanh(z: Complex | number): Complex;
    static atanh(r: number, i?: number): Complex;
    static parse(text: string, context?: IContext): Complex;
    static compile(text: string): () => Complex;
    static compile<T extends any[]>(text: string, reviver: IReviver<T>): (...args: T) => Complex;
    get real(): number;
    get imag(): number;
    get abs(): number;
    get arg(): number;
    toString(format?: string): string;
    equals(rhs: Complex | number): boolean;
    equals(r: number, i?: number): boolean;
    add(rhs: Complex | number): Complex;
    add(r: number, i?: number): Complex;
    sub(rhs: Complex | number): Complex;
    sub(r: number, i?: number): Complex;
    mul(rhs: Complex | number): Complex;
    mul(r: number, i?: number): Complex;
    div(rhs: Complex | number): Complex;
    div(r: number, i?: number): Complex;
    mod(rhs: Complex | number): Complex;
    mod(r: number, i?: number): Complex;
    pow(rhs: Complex | number): Complex;
    pow(r: number, i?: number): Complex;
    and(rhs: Complex | number): Complex;
    and(r: number, i?: number): Complex;
    or(rhs: Complex | number): Complex;
    or(r: number, i?: number): Complex;
    xor(rhs: Complex | number): Complex;
    xor(r: number, i?: number): Complex;
    sal(rhs: Complex | number): Complex;
    sal(r: number, i?: number): Complex;
    shl(rhs: Complex | number): Complex;
    shl(r: number, i?: number): Complex;
    sar(rhs: Complex | number): Complex;
    sar(r: number, i?: number): Complex;
    shr(rhs: Complex | number): Complex;
    shr(r: number, i?: number): Complex;
}

export default Complex;
export { IContext, IReviver };
