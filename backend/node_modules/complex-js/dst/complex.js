'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var nearley = require('nearley');
var moo = _interopDefault(require('moo'));

function from(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var _a, _b, _c, _d;
    var zReal;
    var zImag;
    var zAbs;
    var zArg;
    var zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        // to prevent null values from entering into arithmetic operations
        // e.g. Complex.from(JSON.parse(text))
        zReal = (_a = z._real, (_a !== null && _a !== void 0 ? _a : NaN));
        zImag = (_b = z._imag, (_b !== null && _b !== void 0 ? _b : NaN));
        zAbs = (_c = z._abs, (_c !== null && _c !== void 0 ? _c : NaN));
        zArg = (_d = z._arg, (_d !== null && _d !== void 0 ? _d : NaN));
        zMask = z._mask;
    }
    return new Complex(zReal, zImag, zAbs, zArg, zMask);
}

function imagImpl(abs, arg) {
    return (
    // if z is real, imag = 0
    arg === 0 || arg === Math.PI ? 0
        // else imag = abs * sin(arg)
        : abs * Math.sin(arg));
}

function getImag(z) {
    if (!(z._mask & 2 /* HAS_IMAG */)) {
        z._imag = imagImpl(z._abs, z._arg);
        z._mask |= 2 /* HAS_IMAG */;
    }
    return z._imag;
}

function realImpl(abs, arg) {
    return (
    // if z is positive, real = abs
    arg === 0 ? abs
        // if z is negative, real = -abs
        : arg === Math.PI ? -abs
            // else real = abs * cos(arg)
            : abs * Math.cos(arg));
}

function getReal(z) {
    if (!(z._mask & 1 /* HAS_REAL */)) {
        z._real = realImpl(z._abs, z._arg);
        z._mask |= 1 /* HAS_REAL */;
    }
    return z._real;
}

function add(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal + rhsReal, lhsImag + rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function and(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal & rhsReal, lhsImag & rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function absImpl(real, imag) {
    return (
    // if z is real, abs = |real|
    imag === 0 ? Math.abs(real)
        // if z is imag, abs = |imag|
        : real === 0 ? Math.abs(imag)
            // else abs = |z|
            : Math.hypot(real, imag));
}

function getAbs(z) {
    if (!(z._mask & 4 /* HAS_ABS */)) {
        z._abs = absImpl(z._real, z._imag);
        z._mask |= 4 /* HAS_ABS */;
    }
    return z._abs;
}

function argImpl(real, imag) {
    return (
    // if z is real, if z is negative, arg = pi, else arg = 0
    imag === 0 ? (real < 0 ? Math.PI : 0)
        // if z is imag, arg = sign(imag) * pi / 2
        : real === 0 ? (imag < 0 ? -0.5 : 0.5) * Math.PI
            // else arg = atan(imag / real)
            : Math.atan2(imag, real));
}

function getArg(z) {
    if (!(z._mask & 8 /* HAS_ARG */)) {
        z._arg = argImpl(z._real, z._imag);
        z._mask |= 8 /* HAS_ARG */;
    }
    return z._arg;
}

function div(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhs = typeof r === 'number'
        ? new Complex(r, i, NaN, NaN, 3 /* HAS_CARTESIAN */)
        : r;
    var _mask = lhs._mask & rhs._mask;
    var rhsAbs2;
    switch (_mask) {
        case 15 /* HAS_ALL */:
        case 3 /* HAS_CARTESIAN */ | 4 /* HAS_ABS */:
            rhsAbs2 = rhs._abs * rhs._abs;
            return new Complex((lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2, (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2, lhs._abs / rhs._abs, lhs._arg - rhs._arg, _mask);
        case 3 /* HAS_CARTESIAN */ | 8 /* HAS_ARG */:
            rhsAbs2 = rhs._real * rhs._real + rhs._imag * rhs._imag;
            return new Complex((lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2, (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2, NaN, lhs._arg - rhs._arg, _mask);
        case 3 /* HAS_CARTESIAN */:
        case 1 /* HAS_REAL */:
        case 2 /* HAS_IMAG */:
            rhsAbs2 = getReal(rhs) * rhs._real + getImag(rhs) * rhs._imag;
            return new Complex((getReal(lhs) * rhs._real + getImag(lhs) * rhs._imag) / rhsAbs2, (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2, NaN, NaN, 3 /* HAS_CARTESIAN */);
        default:
            return new Complex(NaN, NaN, getAbs(lhs) / getAbs(rhs), getArg(lhs) - getArg(rhs), 12 /* HAS_POLAR */);
    }
}

function trunc(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.trunc(zReal), Math.trunc(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function mul(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhs = typeof r === 'number'
        ? new Complex(r, i, NaN, NaN, 3 /* HAS_CARTESIAN */)
        : r;
    var _mask = lhs._mask & rhs._mask;
    switch (_mask) {
        case 15 /* HAS_ALL */:
        case 3 /* HAS_CARTESIAN */ | 4 /* HAS_ABS */:
        case 3 /* HAS_CARTESIAN */ | 8 /* HAS_ARG */:
        case 3 /* HAS_CARTESIAN */:
            return new Complex(lhs._real * rhs._real - lhs._imag * rhs._imag, lhs._imag * rhs._real + lhs._real * rhs._imag, lhs._abs * rhs._abs, lhs._arg + rhs._arg, _mask);
        case 1 /* HAS_REAL */:
        case 2 /* HAS_IMAG */:
            return new Complex(getReal(lhs) * getReal(rhs) - getImag(lhs) * getImag(rhs), lhs._imag * rhs._real + lhs._real * rhs._imag, NaN, NaN, 3 /* HAS_CARTESIAN */);
        default:
            return new Complex(NaN, NaN, getAbs(lhs) * getAbs(rhs), getArg(lhs) + getArg(rhs), 12 /* HAS_POLAR */);
    }
}

function sub(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal - rhsReal, lhsImag - rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function mod(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    // lhs % rhs = lhs - (trunc(lhs / rhs) * rhs)
    var q = div(Complex, lhs, r, i);
    var p = mul(Complex, trunc(Complex, q), r, i);
    return sub(Complex, lhs, p);
}

function or(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal | rhsReal, lhsImag | rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function cube(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    var zAbs;
    var zArg;
    var zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    if ((zMask & 3 /* HAS_CARTESIAN */) !== 3 /* HAS_CARTESIAN */) {
        return new Complex(NaN, NaN, zAbs * zAbs * zAbs, 3 * zArg, 12 /* HAS_POLAR */);
    }
    var real2 = zReal * zReal;
    var imag2 = zImag * zImag;
    return new Complex((real2 - 3 * imag2) * zReal, (3 * real2 - imag2) * zImag, zAbs * zAbs * zAbs, 3 * zArg, zMask);
}

function square(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    var zAbs;
    var zArg;
    var zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    if ((zMask & 3 /* HAS_CARTESIAN */) !== 3 /* HAS_CARTESIAN */) {
        return new Complex(NaN, NaN, zAbs * zAbs, 2 * zArg, 12 /* HAS_POLAR */);
    }
    var real2 = zReal * zReal;
    var imag2 = zImag * zImag;
    return new Complex(real2 - imag2, 2 * zReal * zImag, real2 + imag2, 2 * zArg, zMask | 4 /* HAS_ABS */);
}

function pow(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    // rhs = c + di
    var c;
    var d;
    if (typeof r === 'number') {
        c = r;
        d = i;
    }
    else {
        c = getReal(r);
        d = getImag(r);
    }
    if (d === 0) {
        switch (c) {
            case -1: return div(Complex, from(Complex, 1), lhs);
            case 0: return from(Complex, 1);
            case 1: return from(Complex, lhs);
            case 2: return square(Complex, lhs);
            case 3: return cube(Complex, lhs);
        }
    }
    // lhs = m e ** ia
    var m = getAbs(lhs);
    var a = getArg(lhs);
    // lhs ** rhs === (m ** c * e ** -ad) e ** i(d ln(m) + ac)
    // from https://en.wikipedia.org/wiki/Exponentiation#Computing_complex_powers
    var abs = Math.pow(m, c) * Math.exp(-a * d);
    var arg = d * Math.log(m) + a * c;
    return new Complex(NaN, NaN, abs, arg, 12 /* HAS_POLAR */);
}

function sal(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal << rhsReal, lhsImag << rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sar(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal >> rhsReal, lhsImag >> rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function shr(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal >>> rhsReal, lhsImag >>> rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function xor(Complex, lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return new Complex(lhsReal ^ rhsReal, lhsImag ^ rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

var binaryLookup = {
    '%': mod,
    '&': and,
    '*': mul,
    '**': pow,
    '+': add,
    '-': sub,
    '/': div,
    '<<': sal,
    '>>': sar,
    '>>>': shr,
    '^': xor,
    '|': or
};

function abs(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zAbs = typeof z === 'number'
        ? absImpl(z, i)
        : getAbs(z);
    return new Complex(zAbs, 0, zAbs, 0, 15 /* HAS_ALL */);
}

function log(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zAbs;
    var zArg;
    if (typeof z === 'number') {
        zAbs = absImpl(z, i);
        zArg = argImpl(z, i);
    }
    else {
        zAbs = getAbs(z);
        zArg = getArg(z);
    }
    return new Complex(Math.log(zAbs), zArg, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sqrt(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zAbs;
    var zArg;
    if (typeof z === 'number') {
        zAbs = absImpl(z, i);
        zArg = argImpl(z, i);
    }
    else {
        zAbs = getAbs(z);
        zArg = getArg(z);
    }
    return new Complex(NaN, NaN, Math.sqrt(zAbs), 0.5 * zArg, 12 /* HAS_POLAR */);
}

function acos(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var ONE = from(Complex, 1);
    var I = from(Complex, 0, 1);
    var PI_2 = from(Complex, 0.5 * Math.PI);
    var mul1 = mul(Complex, I, z, i);
    var square1 = square(Complex, z, i);
    var sub1 = sub(Complex, ONE, square1);
    var sqrt1 = sqrt(Complex, sub1);
    var add1 = add(Complex, mul1, sqrt1);
    var log1 = log(Complex, add1);
    var mul2 = mul(Complex, I, log1);
    return add(Complex, PI_2, mul2);
}

function acosh(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var ONE = from(Complex, 1);
    var NEG_ONE = from(Complex, -1);
    var add1 = add(Complex, NEG_ONE, z, i);
    var sqrt1 = sqrt(Complex, add1);
    var add2 = add(Complex, ONE, z, i);
    var sqrt2 = sqrt(Complex, add2);
    var mul1 = mul(Complex, sqrt1, sqrt2);
    var add3 = add(Complex, mul1, z, i);
    return log(Complex, add3);
}

function arg(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zArg = typeof z === 'number'
        ? argImpl(z, i)
        : getArg(z);
    return new Complex(zArg, 0, Math.abs(zArg), zArg < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
}

function asin(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var ONE = from(Complex, 1);
    var I = from(Complex, 0, 1);
    var NEG_I = from(Complex, 0, -1);
    var mul1 = mul(Complex, I, z, i);
    var square1 = square(Complex, z, i);
    var sub1 = sub(Complex, ONE, square1);
    var sqrt1 = sqrt(Complex, sub1);
    var add1 = add(Complex, mul1, sqrt1);
    var log1 = log(Complex, add1);
    return mul(Complex, NEG_I, log1);
}

function asinh(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var ONE = from(Complex, 1);
    var square1 = square(Complex, z, i);
    var add1 = add(Complex, ONE, square1);
    var sqrt1 = sqrt(Complex, add1);
    var add2 = add(Complex, sqrt1, z, i);
    return log(Complex, add2);
}

function atan(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var ONE = from(Complex, 1);
    var I = from(Complex, 0, 1);
    var I_2 = from(Complex, 0, 0.5);
    var mul1 = mul(Complex, I, z, i);
    var sub1 = sub(Complex, ONE, mul1);
    var log1 = log(Complex, sub1);
    var add1 = add(Complex, ONE, mul1);
    var log2 = log(Complex, add1);
    var sub2 = sub(Complex, log1, log2);
    return mul(Complex, I_2, sub2);
}

function atanh(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var ONE = from(Complex, 1);
    var ONE_2 = from(Complex, 0.5);
    var add1 = add(Complex, ONE, z, i);
    var log1 = log(Complex, add1);
    var sub1 = sub(Complex, ONE, z, i);
    var log2 = log(Complex, sub1);
    var sub2 = sub(Complex, log1, log2);
    return mul(Complex, ONE_2, sub2);
}

function cbrt(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zAbs;
    var zArg;
    if (typeof z === 'number') {
        zAbs = absImpl(z, i);
        zArg = argImpl(z, i);
    }
    else {
        zAbs = getAbs(z);
        zArg = getArg(z);
    }
    return new Complex(NaN, NaN, Math.pow(zAbs, 1 / 3), zArg / 3, 12 /* HAS_POLAR */);
}

function ceil(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.ceil(zReal), Math.ceil(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function conj(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    var zAbs;
    var zArg;
    var zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    return new Complex(zReal, -zImag, zAbs, -zArg, zMask);
}

function cos(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        var zCos = Math.cos(zReal);
        return new Complex(zCos, 0, Math.abs(zCos), zCos < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        var zCos = Math.cosh(zImag);
        return new Complex(zCos, 0, Math.abs(zCos), zCos < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    return new Complex(Math.cos(zReal) * Math.cosh(zImag), Math.sin(zReal) * Math.sinh(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function cosh(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        var zCosh = Math.cosh(zReal);
        return new Complex(zCosh, 0, Math.abs(zCosh), zCosh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        var zCosh = Math.cos(zImag);
        return new Complex(zCosh, 0, Math.abs(zCosh), zCosh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    return new Complex(Math.cosh(zReal) * Math.cos(zImag), Math.sinh(zReal) * Math.sin(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function exp(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(NaN, NaN, Math.exp(zReal), zImag, 12 /* HAS_POLAR */);
}

function floor(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.floor(zReal), Math.floor(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function imag(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zImag = typeof z === 'number'
        ? imagImpl(z, i)
        : getImag(z);
    return new Complex(zImag, 0, Math.abs(zImag), zImag < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
}

function random(Complex) {
    return new Complex(Math.random(), Math.random(), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function real(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal = typeof z === 'number'
        ? realImpl(z, i)
        : getReal(z);
    return new Complex(zReal, 0, Math.abs(zReal), zReal < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
}

function round(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.round(zReal), Math.round(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sign(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    var zAbs;
    var zArg;
    var zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = absImpl(z, i);
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */ | 4 /* HAS_ABS */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = getAbs(z);
        zArg = z._arg;
        zMask = z._mask;
    }
    if (zAbs === 0) {
        return new Complex(0, 0, 0, 0, 15 /* HAS_ALL */);
    }
    if (zAbs !== Infinity) {
        return new Complex(zReal / zAbs, zImag / zAbs, 1, zArg, zMask | 4 /* HAS_ABS */);
    }
    var zSignArg = typeof z === 'number'
        ? argImpl(zReal, zImag)
        : getArg(z);
    return new Complex(NaN, NaN, 1, zSignArg, 12 /* HAS_POLAR */);
}

function sin(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        var zSin = Math.sin(zReal);
        return new Complex(zSin, 0, Math.abs(zSin), zSin < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        var zSin = Math.sinh(zImag);
        return new Complex(0, zSin, Math.abs(zSin), (zSin < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    return new Complex(Math.sin(zReal) * Math.cosh(zImag), Math.cos(zReal) * Math.sinh(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sinh(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        var zSinh = Math.sinh(zReal);
        return new Complex(zSinh, 0, Math.abs(zSinh), zSinh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        var zSinh = Math.sin(zImag);
        return new Complex(0, zSinh, Math.abs(zSinh), (zSinh < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    return new Complex(Math.sinh(zReal) * Math.cos(zImag), Math.cosh(zReal) * Math.sin(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function tan(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        var zTan = Math.sin(2 * zReal) / (Math.cos(2 * zReal) + 1);
        return new Complex(zTan, 0, Math.abs(zTan), zTan < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        var zTan = Math.sinh(2 * zImag) / (1 + Math.cosh(2 * zImag));
        return new Complex(0, zTan, Math.abs(zTan), (zTan < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    var zTanDenom = Math.cos(2 * zReal) + Math.cosh(2 * zImag);
    return new Complex(Math.sin(2 * zReal) / zTanDenom, Math.sinh(2 * zImag) / zTanDenom, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function tanh(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        var zTanh = Math.sinh(2 * zReal) / (Math.cosh(2 * zReal) + 1);
        return new Complex(zTanh, 0, Math.abs(zTanh), zTanh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        var zTanh = Math.sin(2 * zImag) / (1 + Math.cos(2 * zImag));
        return new Complex(0, zTanh, Math.abs(zTanh), (zTanh < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    var zTanhDenom = Math.cosh(2 * zReal) + Math.cos(2 * zImag);
    return new Complex(Math.sinh(2 * zReal) / zTanhDenom, Math.sin(2 * zImag) / zTanhDenom, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

var callLookup = {
    abs: abs,
    acos: acos,
    acosh: acosh,
    arg: arg,
    asin: asin,
    asinh: asinh,
    atan: atan,
    atanh: atanh,
    cbrt: cbrt,
    ceil: ceil,
    conj: conj,
    cos: cos,
    cosh: cosh,
    cube: cube,
    exp: exp,
    floor: floor,
    imag: imag,
    log: log,
    random: random,
    real: real,
    round: round,
    sign: sign,
    sin: sin,
    sinh: sinh,
    sqrt: sqrt,
    square: square,
    tan: tan,
    tanh: tanh,
    trunc: trunc
};

function neg(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    var zAbs;
    var zArg;
    var zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    return new Complex(-zReal, -zImag, zAbs, zArg + Math.PI, zMask);
}

function not(Complex, z, i) {
    if (i === void 0) { i = 0; }
    var zReal;
    var zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(~zReal, ~zImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

var unaryLookup = {
    '+': from,
    '-': neg,
    '~': not
};

function isConstant(param) {
    return param.length === 0;
}
function areConstant(params) {
    return params.every(isConstant);
}
var literal = function (data) {
    var numericLiteral = data[0];
    return function (Complex) {
        var z = from(Complex, Number(numericLiteral));
        return function () { return z; };
    };
};
function isIndex(key, lookup) {
    var o = Object(lookup);
    return key in o && o[key] !== undefined;
}
function throwInvalidIdentifierName(name) {
    throw new ReferenceError(name + " is not defined");
}
var identifier = function (data) {
    var identifierName = data[0];
    var text = identifierName.text;
    return function () { return function (context) {
        if (!isIndex(text, context)) {
            throwInvalidIdentifierName(text);
        }
        return context[text];
    }; };
};
function throwInvalidCallExpression(name) {
    throw new ReferenceError(name + " is not a function");
}
function concat(t, u) {
    return [t].concat(u);
}
var call = function (data) {
    var identifierName = data[0], expressions = data[2];
    var text = identifierName.text;
    if (!isIndex(text, callLookup)) {
        throwInvalidCallExpression(text);
    }
    return function (Complex) {
        var fn = callLookup[text];
        var variables = expressions.map(function (expression) { return expression(Complex); });
        if (areConstant(variables)) {
            var args = concat(Complex, variables.map(function (constant) { return constant(); }));
            var z_1 = fn.apply(void 0, args);
            return function () { return z_1; };
        }
        return function (context) {
            var args = concat(Complex, variables.map(function (variable) { return variable(context); }));
            return fn.apply(void 0, args);
        };
    };
};
var unary = function (data) {
    var punctuator = data[0], expression = data[2];
    return function (Complex) {
        var fn = unaryLookup[punctuator];
        var variable = expression(Complex);
        if (isConstant(variable)) {
            var z_2 = fn(Complex, variable());
            return function () { return z_2; };
        }
        return function (context) { return fn(Complex, variable(context)); };
    };
};
var binary = function (data) {
    var lhsExpression = data[0], punctuator = data[2], rhsExpression = data[4];
    return function (Complex) {
        var fn = binaryLookup[punctuator];
        var lhs = lhsExpression(Complex);
        var rhs = rhsExpression(Complex);
        if (isConstant(lhs) && isConstant(rhs)) {
            var z_3 = fn(Complex, lhs(), rhs());
            return function () { return z_3; };
        }
        return function (context) { return fn(Complex, lhs(context), rhs(context)); };
    };
};

// Generated automatically by nearley, version 2.19.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
var pick = function (idx) { return function (data) { return data[idx]; }; };
var empty = function () { return []; };
var array = function () {
    var idx = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        idx[_i] = arguments[_i];
    }
    return function (data) { return idx.map(function (i) { return data[i]; }); };
};
var reduce = function (acc, cur) { return function (data) { return data[acc].concat(data[cur]); }; };
var dispose = function () { return null; };
var lexer = moo.compile({
    WhiteSpace: / +/,
    IdentifierName: /[$A-Z_a-z][$\w]*/,
    DecimalLiteral: /(?:(?:0|[1-9]\d*)\.?\d*|\.\d+)(?:[Ee][+-]?\d+)?/,
    BinaryIntegerLiteral: /0[Bb][01]+/,
    OctalIntegerLiteral: /0[Oo][0-7]+/,
    HexIntegerLiteral: /0[Xx][\dA-Fa-f]+/,
    // include update punctuators ++ and -- to enforce whitespace between sequential + and - punctuators
    Punctuator: ['(', ')', '[', ']', '.', ',', '+', '-', '*', '/', '%', '**', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '~'],
});
var grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "Expression", "symbols": ["_", "BitwiseORExpression", "_"], "postprocess": pick(1) },
        { "name": "BitwiseORExpression", "symbols": ["BitwiseORExpression", "_", { "literal": "|" }, "_", "BitwiseXORExpression"], "postprocess": binary },
        { "name": "BitwiseORExpression", "symbols": ["BitwiseXORExpression"], "postprocess": id },
        { "name": "BitwiseXORExpression", "symbols": ["BitwiseXORExpression", "_", { "literal": "^" }, "_", "BitwiseANDExpression"], "postprocess": binary },
        { "name": "BitwiseXORExpression", "symbols": ["BitwiseANDExpression"], "postprocess": id },
        { "name": "BitwiseANDExpression", "symbols": ["BitwiseANDExpression", "_", { "literal": "&" }, "_", "ShiftExpression"], "postprocess": binary },
        { "name": "BitwiseANDExpression", "symbols": ["ShiftExpression"], "postprocess": id },
        { "name": "ShiftExpression", "symbols": ["ShiftExpression", "_", "ShiftOperator", "_", "AdditiveExpression"], "postprocess": binary },
        { "name": "ShiftExpression", "symbols": ["AdditiveExpression"], "postprocess": id },
        { "name": "ShiftOperator", "symbols": [{ "literal": "<<" }], "postprocess": id },
        { "name": "ShiftOperator", "symbols": [{ "literal": ">>" }], "postprocess": id },
        { "name": "ShiftOperator", "symbols": [{ "literal": ">>>" }], "postprocess": id },
        { "name": "AdditiveExpression", "symbols": ["AdditiveExpression", "_", "AdditiveOperator", "_", "MultiplicativeExpression"], "postprocess": binary },
        { "name": "AdditiveExpression", "symbols": ["MultiplicativeExpression"], "postprocess": id },
        { "name": "AdditiveOperator", "symbols": [{ "literal": "+" }], "postprocess": id },
        { "name": "AdditiveOperator", "symbols": [{ "literal": "-" }], "postprocess": id },
        { "name": "MultiplicativeExpression", "symbols": ["MultiplicativeExpression", "_", "MultiplicativeOperator", "_", "ExponentiationExpression"], "postprocess": binary },
        { "name": "MultiplicativeExpression", "symbols": ["ExponentiationExpression"], "postprocess": id },
        { "name": "MultiplicativeOperator", "symbols": [{ "literal": "*" }], "postprocess": id },
        { "name": "MultiplicativeOperator", "symbols": [{ "literal": "/" }], "postprocess": id },
        { "name": "MultiplicativeOperator", "symbols": [{ "literal": "%" }], "postprocess": id },
        { "name": "ExponentiationExpression", "symbols": ["LeftHandSideExpression", "_", { "literal": "**" }, "_", "ExponentiationExpression"], "postprocess": binary },
        { "name": "ExponentiationExpression", "symbols": ["UnaryExpression"], "postprocess": id },
        { "name": "UnaryExpression", "symbols": ["UnaryOperator", "_", "UnaryExpression"], "postprocess": unary },
        { "name": "UnaryExpression", "symbols": ["LeftHandSideExpression"], "postprocess": id },
        { "name": "UnaryOperator", "symbols": [{ "literal": "+" }], "postprocess": id },
        { "name": "UnaryOperator", "symbols": [{ "literal": "-" }], "postprocess": id },
        { "name": "UnaryOperator", "symbols": [{ "literal": "~" }], "postprocess": id },
        { "name": "LeftHandSideExpression", "symbols": ["ParenthesizedExpression"], "postprocess": id },
        { "name": "LeftHandSideExpression", "symbols": ["PrimaryExpression"], "postprocess": id },
        { "name": "ParenthesizedExpression", "symbols": [{ "literal": "(" }, "_", "BitwiseORExpression", "_", { "literal": ")" }], "postprocess": pick(2) },
        { "name": "ParenthesizedExpression", "symbols": [{ "literal": "[" }, "_", "BitwiseORExpression", "_", { "literal": "]" }], "postprocess": pick(2) },
        { "name": "PrimaryExpression", "symbols": ["CallExpression"], "postprocess": id },
        { "name": "PrimaryExpression", "symbols": [(lexer.has("IdentifierName") ? { type: "IdentifierName" } : IdentifierName)], "postprocess": identifier },
        { "name": "PrimaryExpression", "symbols": ["NumericLiteral"], "postprocess": literal },
        { "name": "NumericLiteral", "symbols": [(lexer.has("DecimalLiteral") ? { type: "DecimalLiteral" } : DecimalLiteral)], "postprocess": id },
        { "name": "NumericLiteral", "symbols": [(lexer.has("BinaryIntegerLiteral") ? { type: "BinaryIntegerLiteral" } : BinaryIntegerLiteral)], "postprocess": id },
        { "name": "NumericLiteral", "symbols": [(lexer.has("OctalIntegerLiteral") ? { type: "OctalIntegerLiteral" } : OctalIntegerLiteral)], "postprocess": id },
        { "name": "NumericLiteral", "symbols": [(lexer.has("HexIntegerLiteral") ? { type: "HexIntegerLiteral" } : HexIntegerLiteral)], "postprocess": id },
        { "name": "CallExpression", "symbols": [(lexer.has("IdentifierName") ? { type: "IdentifierName" } : IdentifierName), "_", "Arguments"], "postprocess": call },
        { "name": "Arguments", "symbols": [{ "literal": "(" }, "_", "ArgumentList", "_", { "literal": ")" }], "postprocess": pick(2) },
        { "name": "Arguments", "symbols": [{ "literal": "(" }, "_", { "literal": ")" }], "postprocess": empty },
        { "name": "ArgumentList", "symbols": ["ArgumentList", "_", { "literal": "," }, "_", "BitwiseORExpression"], "postprocess": reduce(0, 4) },
        { "name": "ArgumentList", "symbols": ["BitwiseORExpression"], "postprocess": array(0) },
        { "name": "_$ebnf$1", "symbols": [(lexer.has("WhiteSpace") ? { type: "WhiteSpace" } : WhiteSpace)], "postprocess": id },
        { "name": "_$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": dispose }
    ],
    ParserStart: "Expression",
};

var rules = nearley.Grammar.fromCompiled(grammar);
function generate(Complex, text) {
    var parser = new nearley.Parser(rules);
    var results = parser.feed(text).results;
    switch (results.length) {
        case 0:
            throw new Error('Unexpected end of input');
        case 1:
            var expression = results[0];
            return expression(Complex);
        default:
            throw new Error('Ambiguous grammar');
    }
}

function compile(Complex, text, reviver) {
    var variable = generate(Complex, text);
    if (reviver) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return variable(reviver.apply(void 0, args));
        };
    }
    var z = variable({});
    return function () { return z; };
}

function parse(Complex, text, context) {
    var variable = generate(Complex, text);
    return variable(context);
}

function polar(Complex, abs, arg) {
    if (arg === void 0) { arg = 0; }
    var zAbs;
    var zArg;
    if (abs < 0) {
        zAbs = -abs;
        zArg = arg + Math.PI;
    }
    else {
        zAbs = abs;
        zArg = arg;
    }
    return new Complex(NaN, NaN, zAbs, zArg, 12 /* HAS_POLAR */);
}

function equals(lhs, r, i) {
    if (i === void 0) { i = 0; }
    var rhsReal;
    var rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    var lhsReal = getReal(lhs);
    var lhsImag = getImag(lhs);
    return lhsReal === rhsReal && lhsImag === rhsImag;
}

var fmtCoord = /%([cp])/g;
var fmtParts = /%([#0+-]{0,4})(\d{0,2})((?:\.\d{0,2})?)([Xxob]?)([rima])/g;
function toString(z, format) {
    if (format === void 0) { format = '%c'; }
    return format
        .replace(fmtCoord, replaceCoord)
        .replace(fmtParts, replaceParts(z));
}
function replaceCoord(_, coord) {
    switch (coord) {
        case 'c': return '%r%+i*i';
        case 'p': return '%m*e**(%a*i)';
    }
}
function replaceParts(z) {
    return function (_, flag, width, precision, radix, specifier) {
        return stringify(z, {
            minus: flag.includes('-'),
            plus: flag.includes('+'),
            pound: flag.includes('#'),
            precision: precision && +precision.slice(1),
            radix: radix,
            specifier: specifier,
            width: +width,
            zero: flag.includes('0')
        });
    };
}
function stringify(z, format) {
    return width(precision(radix(specifier())));
    function specifier() {
        switch (format.specifier) {
            case 'r': return getReal(z);
            case 'i': return getImag(z);
            case 'm': return getAbs(z);
            case 'a': return getArg(z);
        }
    }
    function radix(num) {
        switch (format.radix) {
            case 'X': return num.toString(16).toUpperCase();
            case 'x': return num.toString(16).toLowerCase();
            case 'o': return num.toString(8);
            case 'b': return num.toString(2);
            case '': return num.toString(10);
        }
    }
    function precision(str) {
        var target = format.precision;
        var index = str.indexOf('.') + 1;
        if (target === '')
            return str;
        if (index === 0) {
            if (target === 0)
                return str;
            return str + "." + '0'.repeat(target);
        }
        var digits = str.length - index;
        var remove = Math.max(digits - target, 0);
        var insert = Math.max(target - digits, 0);
        return str.slice(0, str.length - remove) + '0'.repeat(insert);
    }
    function width(str) {
        if (format.minus) {
            return plus(pound(str)).padEnd(format.width, ' ');
        }
        if (!format.zero) {
            return plus(pound(str)).padStart(format.width, ' ');
        }
        if (!str.startsWith('-')) {
            return plus(pound(str.padStart(format.width, '0')));
        }
        return plus(pound("-" + str.slice(1).padStart(format.width - 1, '0')));
    }
    function plus(str) {
        if (!format.plus || str.startsWith('-')) {
            return str;
        }
        return "+" + str;
    }
    function pound(str) {
        if (!format.pound || !format.radix) {
            return str;
        }
        var base = "0" + format.radix;
        if (!str.startsWith('-')) {
            return base + str;
        }
        return "-" + (base + str.slice(1));
    }
}

var Complex = /** @class */ (function () {
    /**
     * @internal
     */
    function Complex(_real, _imag, _abs, _arg, _mask) {
        // coerce -0 to +0
        this._real = _real + 0;
        this._imag = _imag + 0;
        this._abs = _abs + 0;
        // choose branch cut as the interval (-pi, pi]
        this._arg = Math.PI - ((Math.PI - _arg) % (Math.PI * 2));
        this._mask = _mask;
    }
    Complex.from = function (z, i) {
        return from(Complex, z, i);
    };
    Complex.cartesian = function (r, i) {
        if (i === void 0) { i = 0; }
        return new Complex(r, i, NaN, NaN, 3 /* HAS_CARTESIAN */);
    };
    Complex.polar = function (abs, arg) {
        return polar(Complex, abs, arg);
    };
    Complex.real = function (z, i) {
        return real(Complex, z, i);
    };
    Complex.imag = function (z, i) {
        return imag(Complex, z, i);
    };
    Complex.abs = function (z, i) {
        return abs(Complex, z, i);
    };
    Complex.arg = function (z, i) {
        return arg(Complex, z, i);
    };
    Complex.neg = function (z, i) {
        return neg(Complex, z, i);
    };
    Complex.conj = function (z, i) {
        return conj(Complex, z, i);
    };
    Complex.floor = function (z, i) {
        return floor(Complex, z, i);
    };
    Complex.ceil = function (z, i) {
        return ceil(Complex, z, i);
    };
    Complex.round = function (z, i) {
        return round(Complex, z, i);
    };
    Complex.sign = function (z, i) {
        return sign(Complex, z, i);
    };
    Complex.trunc = function (z, i) {
        return trunc(Complex, z, i);
    };
    Complex.not = function (z, i) {
        return not(Complex, z, i);
    };
    Complex.random = function () {
        return random(Complex);
    };
    Complex.sqrt = function (z, i) {
        return sqrt(Complex, z, i);
    };
    Complex.cbrt = function (z, i) {
        return cbrt(Complex, z, i);
    };
    Complex.square = function (z, i) {
        return square(Complex, z, i);
    };
    Complex.cube = function (z, i) {
        return cube(Complex, z, i);
    };
    Complex.exp = function (z, i) {
        return exp(Complex, z, i);
    };
    Complex.log = function (z, i) {
        return log(Complex, z, i);
    };
    Complex.cos = function (z, i) {
        return cos(Complex, z, i);
    };
    Complex.sin = function (z, i) {
        return sin(Complex, z, i);
    };
    Complex.tan = function (z, i) {
        return tan(Complex, z, i);
    };
    Complex.acos = function (z, i) {
        return acos(Complex, z, i);
    };
    Complex.asin = function (z, i) {
        return asin(Complex, z, i);
    };
    Complex.atan = function (z, i) {
        return atan(Complex, z, i);
    };
    Complex.cosh = function (z, i) {
        return cosh(Complex, z, i);
    };
    Complex.sinh = function (z, i) {
        return sinh(Complex, z, i);
    };
    Complex.tanh = function (z, i) {
        return tanh(Complex, z, i);
    };
    Complex.acosh = function (z, i) {
        return acosh(Complex, z, i);
    };
    Complex.asinh = function (z, i) {
        return asinh(Complex, z, i);
    };
    Complex.atanh = function (z, i) {
        return atanh(Complex, z, i);
    };
    Complex.parse = function (text, context) {
        return parse(Complex, text, context);
    };
    Complex.compile = function (text, reviver) {
        return compile(Complex, text, reviver);
    };
    Object.defineProperty(Complex.prototype, "real", {
        get: function () {
            return getReal(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Complex.prototype, "imag", {
        get: function () {
            return getImag(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Complex.prototype, "abs", {
        get: function () {
            return getAbs(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Complex.prototype, "arg", {
        get: function () {
            return getArg(this);
        },
        enumerable: true,
        configurable: true
    });
    Complex.prototype.toString = function (format) {
        return toString(this, format);
    };
    Complex.prototype.equals = function (r, i) {
        return equals(this, r, i);
    };
    Complex.prototype.add = function (r, i) {
        return add(Complex, this, r, i);
    };
    Complex.prototype.sub = function (r, i) {
        return sub(Complex, this, r, i);
    };
    Complex.prototype.mul = function (r, i) {
        return mul(Complex, this, r, i);
    };
    Complex.prototype.div = function (r, i) {
        return div(Complex, this, r, i);
    };
    Complex.prototype.mod = function (r, i) {
        return mod(Complex, this, r, i);
    };
    Complex.prototype.pow = function (r, i) {
        return pow(Complex, this, r, i);
    };
    Complex.prototype.and = function (r, i) {
        return and(Complex, this, r, i);
    };
    Complex.prototype.or = function (r, i) {
        return or(Complex, this, r, i);
    };
    Complex.prototype.xor = function (r, i) {
        return xor(Complex, this, r, i);
    };
    Complex.prototype.sal = function (r, i) {
        return sal(Complex, this, r, i);
    };
    Complex.prototype.shl = function (r, i) {
        return sal(Complex, this, r, i);
    };
    Complex.prototype.sar = function (r, i) {
        return sar(Complex, this, r, i);
    };
    Complex.prototype.shr = function (r, i) {
        return shr(Complex, this, r, i);
    };
    Complex['0'] = Complex.from(0);
    Complex['1'] = Complex.from(1);
    Complex['I'] = Complex.from(0, 1);
    Complex['E'] = Complex.from(Math.E);
    Complex['LN2'] = Complex.from(Math.LN2);
    Complex['LN10'] = Complex.from(Math.LN10);
    Complex['LOG2E'] = Complex.from(Math.LOG2E);
    Complex['LOG10E'] = Complex.from(Math.LOG10E);
    Complex['PI'] = Complex.from(Math.PI);
    Complex['SQRT1_2'] = Complex.from(Math.SQRT1_2);
    Complex['SQRT2'] = Complex.from(Math.SQRT2);
    return Complex;
}());

module.exports = Complex;
