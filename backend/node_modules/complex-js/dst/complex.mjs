import { Parser, Grammar } from 'nearley';
import moo from 'moo';

function from(Complex, z, i = 0) {
    var _a, _b, _c, _d;
    let zReal;
    let zImag;
    let zAbs;
    let zArg;
    let zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        // to prevent null values from entering into arithmetic operations
        // e.g. Complex.from(JSON.parse(text))
        zReal = (_a = z._real, (_a !== null && _a !== void 0 ? _a : NaN));
        zImag = (_b = z._imag, (_b !== null && _b !== void 0 ? _b : NaN));
        zAbs = (_c = z._abs, (_c !== null && _c !== void 0 ? _c : NaN));
        zArg = (_d = z._arg, (_d !== null && _d !== void 0 ? _d : NaN));
        zMask = z._mask;
    }
    return new Complex(zReal, zImag, zAbs, zArg, zMask);
}

function imagImpl(abs, arg) {
    return (
    // if z is real, imag = 0
    arg === 0 || arg === Math.PI ? 0
        // else imag = abs * sin(arg)
        : abs * Math.sin(arg));
}

function getImag(z) {
    if (!(z._mask & 2 /* HAS_IMAG */)) {
        z._imag = imagImpl(z._abs, z._arg);
        z._mask |= 2 /* HAS_IMAG */;
    }
    return z._imag;
}

function realImpl(abs, arg) {
    return (
    // if z is positive, real = abs
    arg === 0 ? abs
        // if z is negative, real = -abs
        : arg === Math.PI ? -abs
            // else real = abs * cos(arg)
            : abs * Math.cos(arg));
}

function getReal(z) {
    if (!(z._mask & 1 /* HAS_REAL */)) {
        z._real = realImpl(z._abs, z._arg);
        z._mask |= 1 /* HAS_REAL */;
    }
    return z._real;
}

function add(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal + rhsReal, lhsImag + rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function and(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal & rhsReal, lhsImag & rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function absImpl(real, imag) {
    return (
    // if z is real, abs = |real|
    imag === 0 ? Math.abs(real)
        // if z is imag, abs = |imag|
        : real === 0 ? Math.abs(imag)
            // else abs = |z|
            : Math.hypot(real, imag));
}

function getAbs(z) {
    if (!(z._mask & 4 /* HAS_ABS */)) {
        z._abs = absImpl(z._real, z._imag);
        z._mask |= 4 /* HAS_ABS */;
    }
    return z._abs;
}

function argImpl(real, imag) {
    return (
    // if z is real, if z is negative, arg = pi, else arg = 0
    imag === 0 ? (real < 0 ? Math.PI : 0)
        // if z is imag, arg = sign(imag) * pi / 2
        : real === 0 ? (imag < 0 ? -0.5 : 0.5) * Math.PI
            // else arg = atan(imag / real)
            : Math.atan2(imag, real));
}

function getArg(z) {
    if (!(z._mask & 8 /* HAS_ARG */)) {
        z._arg = argImpl(z._real, z._imag);
        z._mask |= 8 /* HAS_ARG */;
    }
    return z._arg;
}

function div(Complex, lhs, r, i = 0) {
    const rhs = typeof r === 'number'
        ? new Complex(r, i, NaN, NaN, 3 /* HAS_CARTESIAN */)
        : r;
    const _mask = lhs._mask & rhs._mask;
    let rhsAbs2;
    switch (_mask) {
        case 15 /* HAS_ALL */:
        case 3 /* HAS_CARTESIAN */ | 4 /* HAS_ABS */:
            rhsAbs2 = rhs._abs * rhs._abs;
            return new Complex((lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2, (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2, lhs._abs / rhs._abs, lhs._arg - rhs._arg, _mask);
        case 3 /* HAS_CARTESIAN */ | 8 /* HAS_ARG */:
            rhsAbs2 = rhs._real * rhs._real + rhs._imag * rhs._imag;
            return new Complex((lhs._real * rhs._real + lhs._imag * rhs._imag) / rhsAbs2, (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2, NaN, lhs._arg - rhs._arg, _mask);
        case 3 /* HAS_CARTESIAN */:
        case 1 /* HAS_REAL */:
        case 2 /* HAS_IMAG */:
            rhsAbs2 = getReal(rhs) * rhs._real + getImag(rhs) * rhs._imag;
            return new Complex((getReal(lhs) * rhs._real + getImag(lhs) * rhs._imag) / rhsAbs2, (lhs._imag * rhs._real - lhs._real * rhs._imag) / rhsAbs2, NaN, NaN, 3 /* HAS_CARTESIAN */);
        default:
            return new Complex(NaN, NaN, getAbs(lhs) / getAbs(rhs), getArg(lhs) - getArg(rhs), 12 /* HAS_POLAR */);
    }
}

function trunc(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.trunc(zReal), Math.trunc(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function mul(Complex, lhs, r, i = 0) {
    const rhs = typeof r === 'number'
        ? new Complex(r, i, NaN, NaN, 3 /* HAS_CARTESIAN */)
        : r;
    const _mask = lhs._mask & rhs._mask;
    switch (_mask) {
        case 15 /* HAS_ALL */:
        case 3 /* HAS_CARTESIAN */ | 4 /* HAS_ABS */:
        case 3 /* HAS_CARTESIAN */ | 8 /* HAS_ARG */:
        case 3 /* HAS_CARTESIAN */:
            return new Complex(lhs._real * rhs._real - lhs._imag * rhs._imag, lhs._imag * rhs._real + lhs._real * rhs._imag, lhs._abs * rhs._abs, lhs._arg + rhs._arg, _mask);
        case 1 /* HAS_REAL */:
        case 2 /* HAS_IMAG */:
            return new Complex(getReal(lhs) * getReal(rhs) - getImag(lhs) * getImag(rhs), lhs._imag * rhs._real + lhs._real * rhs._imag, NaN, NaN, 3 /* HAS_CARTESIAN */);
        default:
            return new Complex(NaN, NaN, getAbs(lhs) * getAbs(rhs), getArg(lhs) + getArg(rhs), 12 /* HAS_POLAR */);
    }
}

function sub(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal - rhsReal, lhsImag - rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function mod(Complex, lhs, r, i = 0) {
    // lhs % rhs = lhs - (trunc(lhs / rhs) * rhs)
    const q = div(Complex, lhs, r, i);
    const p = mul(Complex, trunc(Complex, q), r, i);
    return sub(Complex, lhs, p);
}

function or(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal | rhsReal, lhsImag | rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function cube(Complex, z, i = 0) {
    let zReal;
    let zImag;
    let zAbs;
    let zArg;
    let zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    if ((zMask & 3 /* HAS_CARTESIAN */) !== 3 /* HAS_CARTESIAN */) {
        return new Complex(NaN, NaN, zAbs * zAbs * zAbs, 3 * zArg, 12 /* HAS_POLAR */);
    }
    const real2 = zReal * zReal;
    const imag2 = zImag * zImag;
    return new Complex((real2 - 3 * imag2) * zReal, (3 * real2 - imag2) * zImag, zAbs * zAbs * zAbs, 3 * zArg, zMask);
}

function square(Complex, z, i = 0) {
    let zReal;
    let zImag;
    let zAbs;
    let zArg;
    let zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    if ((zMask & 3 /* HAS_CARTESIAN */) !== 3 /* HAS_CARTESIAN */) {
        return new Complex(NaN, NaN, zAbs * zAbs, 2 * zArg, 12 /* HAS_POLAR */);
    }
    const real2 = zReal * zReal;
    const imag2 = zImag * zImag;
    return new Complex(real2 - imag2, 2 * zReal * zImag, real2 + imag2, 2 * zArg, zMask | 4 /* HAS_ABS */);
}

function pow(Complex, lhs, r, i = 0) {
    // rhs = c + di
    let c;
    let d;
    if (typeof r === 'number') {
        c = r;
        d = i;
    }
    else {
        c = getReal(r);
        d = getImag(r);
    }
    if (d === 0) {
        switch (c) {
            case -1: return div(Complex, from(Complex, 1), lhs);
            case 0: return from(Complex, 1);
            case 1: return from(Complex, lhs);
            case 2: return square(Complex, lhs);
            case 3: return cube(Complex, lhs);
        }
    }
    // lhs = m e ** ia
    const m = getAbs(lhs);
    const a = getArg(lhs);
    // lhs ** rhs === (m ** c * e ** -ad) e ** i(d ln(m) + ac)
    // from https://en.wikipedia.org/wiki/Exponentiation#Computing_complex_powers
    const abs = Math.pow(m, c) * Math.exp(-a * d);
    const arg = d * Math.log(m) + a * c;
    return new Complex(NaN, NaN, abs, arg, 12 /* HAS_POLAR */);
}

function sal(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal << rhsReal, lhsImag << rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sar(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal >> rhsReal, lhsImag >> rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function shr(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal >>> rhsReal, lhsImag >>> rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function xor(Complex, lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return new Complex(lhsReal ^ rhsReal, lhsImag ^ rhsImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

const binaryLookup = {
    '%': mod,
    '&': and,
    '*': mul,
    '**': pow,
    '+': add,
    '-': sub,
    '/': div,
    '<<': sal,
    '>>': sar,
    '>>>': shr,
    '^': xor,
    '|': or
};

function abs(Complex, z, i = 0) {
    const zAbs = typeof z === 'number'
        ? absImpl(z, i)
        : getAbs(z);
    return new Complex(zAbs, 0, zAbs, 0, 15 /* HAS_ALL */);
}

function log(Complex, z, i = 0) {
    let zAbs;
    let zArg;
    if (typeof z === 'number') {
        zAbs = absImpl(z, i);
        zArg = argImpl(z, i);
    }
    else {
        zAbs = getAbs(z);
        zArg = getArg(z);
    }
    return new Complex(Math.log(zAbs), zArg, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sqrt(Complex, z, i = 0) {
    let zAbs;
    let zArg;
    if (typeof z === 'number') {
        zAbs = absImpl(z, i);
        zArg = argImpl(z, i);
    }
    else {
        zAbs = getAbs(z);
        zArg = getArg(z);
    }
    return new Complex(NaN, NaN, Math.sqrt(zAbs), 0.5 * zArg, 12 /* HAS_POLAR */);
}

function acos(Complex, z, i = 0) {
    const ONE = from(Complex, 1);
    const I = from(Complex, 0, 1);
    const PI_2 = from(Complex, 0.5 * Math.PI);
    const mul1 = mul(Complex, I, z, i);
    const square1 = square(Complex, z, i);
    const sub1 = sub(Complex, ONE, square1);
    const sqrt1 = sqrt(Complex, sub1);
    const add1 = add(Complex, mul1, sqrt1);
    const log1 = log(Complex, add1);
    const mul2 = mul(Complex, I, log1);
    return add(Complex, PI_2, mul2);
}

function acosh(Complex, z, i = 0) {
    const ONE = from(Complex, 1);
    const NEG_ONE = from(Complex, -1);
    const add1 = add(Complex, NEG_ONE, z, i);
    const sqrt1 = sqrt(Complex, add1);
    const add2 = add(Complex, ONE, z, i);
    const sqrt2 = sqrt(Complex, add2);
    const mul1 = mul(Complex, sqrt1, sqrt2);
    const add3 = add(Complex, mul1, z, i);
    return log(Complex, add3);
}

function arg(Complex, z, i = 0) {
    const zArg = typeof z === 'number'
        ? argImpl(z, i)
        : getArg(z);
    return new Complex(zArg, 0, Math.abs(zArg), zArg < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
}

function asin(Complex, z, i = 0) {
    const ONE = from(Complex, 1);
    const I = from(Complex, 0, 1);
    const NEG_I = from(Complex, 0, -1);
    const mul1 = mul(Complex, I, z, i);
    const square1 = square(Complex, z, i);
    const sub1 = sub(Complex, ONE, square1);
    const sqrt1 = sqrt(Complex, sub1);
    const add1 = add(Complex, mul1, sqrt1);
    const log1 = log(Complex, add1);
    return mul(Complex, NEG_I, log1);
}

function asinh(Complex, z, i = 0) {
    const ONE = from(Complex, 1);
    const square1 = square(Complex, z, i);
    const add1 = add(Complex, ONE, square1);
    const sqrt1 = sqrt(Complex, add1);
    const add2 = add(Complex, sqrt1, z, i);
    return log(Complex, add2);
}

function atan(Complex, z, i = 0) {
    const ONE = from(Complex, 1);
    const I = from(Complex, 0, 1);
    const I_2 = from(Complex, 0, 0.5);
    const mul1 = mul(Complex, I, z, i);
    const sub1 = sub(Complex, ONE, mul1);
    const log1 = log(Complex, sub1);
    const add1 = add(Complex, ONE, mul1);
    const log2 = log(Complex, add1);
    const sub2 = sub(Complex, log1, log2);
    return mul(Complex, I_2, sub2);
}

function atanh(Complex, z, i = 0) {
    const ONE = from(Complex, 1);
    const ONE_2 = from(Complex, 0.5);
    const add1 = add(Complex, ONE, z, i);
    const log1 = log(Complex, add1);
    const sub1 = sub(Complex, ONE, z, i);
    const log2 = log(Complex, sub1);
    const sub2 = sub(Complex, log1, log2);
    return mul(Complex, ONE_2, sub2);
}

function cbrt(Complex, z, i = 0) {
    let zAbs;
    let zArg;
    if (typeof z === 'number') {
        zAbs = absImpl(z, i);
        zArg = argImpl(z, i);
    }
    else {
        zAbs = getAbs(z);
        zArg = getArg(z);
    }
    return new Complex(NaN, NaN, Math.pow(zAbs, 1 / 3), zArg / 3, 12 /* HAS_POLAR */);
}

function ceil(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.ceil(zReal), Math.ceil(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function conj(Complex, z, i = 0) {
    let zReal;
    let zImag;
    let zAbs;
    let zArg;
    let zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    return new Complex(zReal, -zImag, zAbs, -zArg, zMask);
}

function cos(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        const zCos = Math.cos(zReal);
        return new Complex(zCos, 0, Math.abs(zCos), zCos < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        const zCos = Math.cosh(zImag);
        return new Complex(zCos, 0, Math.abs(zCos), zCos < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    return new Complex(Math.cos(zReal) * Math.cosh(zImag), Math.sin(zReal) * Math.sinh(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function cosh(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        const zCosh = Math.cosh(zReal);
        return new Complex(zCosh, 0, Math.abs(zCosh), zCosh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        const zCosh = Math.cos(zImag);
        return new Complex(zCosh, 0, Math.abs(zCosh), zCosh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    return new Complex(Math.cosh(zReal) * Math.cos(zImag), Math.sinh(zReal) * Math.sin(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function exp(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(NaN, NaN, Math.exp(zReal), zImag, 12 /* HAS_POLAR */);
}

function floor(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.floor(zReal), Math.floor(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function imag(Complex, z, i = 0) {
    const zImag = typeof z === 'number'
        ? imagImpl(z, i)
        : getImag(z);
    return new Complex(zImag, 0, Math.abs(zImag), zImag < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
}

function random(Complex) {
    return new Complex(Math.random(), Math.random(), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function real(Complex, z, i = 0) {
    const zReal = typeof z === 'number'
        ? realImpl(z, i)
        : getReal(z);
    return new Complex(zReal, 0, Math.abs(zReal), zReal < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
}

function round(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(Math.round(zReal), Math.round(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sign(Complex, z, i = 0) {
    let zReal;
    let zImag;
    let zAbs;
    let zArg;
    let zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = absImpl(z, i);
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */ | 4 /* HAS_ABS */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = getAbs(z);
        zArg = z._arg;
        zMask = z._mask;
    }
    if (zAbs === 0) {
        return new Complex(0, 0, 0, 0, 15 /* HAS_ALL */);
    }
    if (zAbs !== Infinity) {
        return new Complex(zReal / zAbs, zImag / zAbs, 1, zArg, zMask | 4 /* HAS_ABS */);
    }
    const zSignArg = typeof z === 'number'
        ? argImpl(zReal, zImag)
        : getArg(z);
    return new Complex(NaN, NaN, 1, zSignArg, 12 /* HAS_POLAR */);
}

function sin(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        const zSin = Math.sin(zReal);
        return new Complex(zSin, 0, Math.abs(zSin), zSin < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        const zSin = Math.sinh(zImag);
        return new Complex(0, zSin, Math.abs(zSin), (zSin < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    return new Complex(Math.sin(zReal) * Math.cosh(zImag), Math.cos(zReal) * Math.sinh(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function sinh(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        const zSinh = Math.sinh(zReal);
        return new Complex(zSinh, 0, Math.abs(zSinh), zSinh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        const zSinh = Math.sin(zImag);
        return new Complex(0, zSinh, Math.abs(zSinh), (zSinh < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    return new Complex(Math.sinh(zReal) * Math.cos(zImag), Math.cosh(zReal) * Math.sin(zImag), NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function tan(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        const zTan = Math.sin(2 * zReal) / (Math.cos(2 * zReal) + 1);
        return new Complex(zTan, 0, Math.abs(zTan), zTan < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        const zTan = Math.sinh(2 * zImag) / (1 + Math.cosh(2 * zImag));
        return new Complex(0, zTan, Math.abs(zTan), (zTan < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    const zTanDenom = Math.cos(2 * zReal) + Math.cosh(2 * zImag);
    return new Complex(Math.sin(2 * zReal) / zTanDenom, Math.sinh(2 * zImag) / zTanDenom, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

function tanh(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    if (zImag === 0) {
        const zTanh = Math.sinh(2 * zReal) / (Math.cosh(2 * zReal) + 1);
        return new Complex(zTanh, 0, Math.abs(zTanh), zTanh < 0 ? Math.PI : 0, 15 /* HAS_ALL */);
    }
    if (zReal === 0) {
        const zTanh = Math.sin(2 * zImag) / (1 + Math.cos(2 * zImag));
        return new Complex(0, zTanh, Math.abs(zTanh), (zTanh < 0 ? -0.5 : 0.5) * Math.PI, 15 /* HAS_ALL */);
    }
    const zTanhDenom = Math.cosh(2 * zReal) + Math.cos(2 * zImag);
    return new Complex(Math.sinh(2 * zReal) / zTanhDenom, Math.sin(2 * zImag) / zTanhDenom, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

const callLookup = {
    abs,
    acos,
    acosh,
    arg,
    asin,
    asinh,
    atan,
    atanh,
    cbrt,
    ceil,
    conj,
    cos,
    cosh,
    cube,
    exp,
    floor,
    imag,
    log,
    random,
    real,
    round,
    sign,
    sin,
    sinh,
    sqrt,
    square,
    tan,
    tanh,
    trunc
};

function neg(Complex, z, i = 0) {
    let zReal;
    let zImag;
    let zAbs;
    let zArg;
    let zMask;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
        zAbs = NaN;
        zArg = NaN;
        zMask = 3 /* HAS_CARTESIAN */;
    }
    else {
        zReal = z._real;
        zImag = z._imag;
        zAbs = z._abs;
        zArg = z._arg;
        zMask = z._mask;
    }
    return new Complex(-zReal, -zImag, zAbs, zArg + Math.PI, zMask);
}

function not(Complex, z, i = 0) {
    let zReal;
    let zImag;
    if (typeof z === 'number') {
        zReal = z;
        zImag = i;
    }
    else {
        zReal = getReal(z);
        zImag = getImag(z);
    }
    return new Complex(~zReal, ~zImag, NaN, NaN, 3 /* HAS_CARTESIAN */);
}

const unaryLookup = {
    '+': from,
    '-': neg,
    '~': not
};

function isConstant(param) {
    return param.length === 0;
}
function areConstant(params) {
    return params.every(isConstant);
}
const literal = (data) => {
    const [numericLiteral] = data;
    return (Complex) => {
        const z = from(Complex, Number(numericLiteral));
        return () => z;
    };
};
function isIndex(key, lookup) {
    const o = Object(lookup);
    return key in o && o[key] !== undefined;
}
function throwInvalidIdentifierName(name) {
    throw new ReferenceError(`${name} is not defined`);
}
const identifier = (data) => {
    const [identifierName] = data;
    const { text } = identifierName;
    return () => (context) => {
        if (!isIndex(text, context)) {
            throwInvalidIdentifierName(text);
        }
        return context[text];
    };
};
function throwInvalidCallExpression(name) {
    throw new ReferenceError(`${name} is not a function`);
}
function concat(t, u) {
    return [t].concat(u);
}
const call = (data) => {
    const [identifierName, , expressions] = data;
    const { text } = identifierName;
    if (!isIndex(text, callLookup)) {
        throwInvalidCallExpression(text);
    }
    return (Complex) => {
        const fn = callLookup[text];
        const variables = expressions.map(expression => expression(Complex));
        if (areConstant(variables)) {
            const args = concat(Complex, variables.map(constant => constant()));
            const z = fn(...args);
            return () => z;
        }
        return (context) => {
            const args = concat(Complex, variables.map(variable => variable(context)));
            return fn(...args);
        };
    };
};
const unary = (data) => {
    const [punctuator, , expression] = data;
    return Complex => {
        const fn = unaryLookup[punctuator];
        const variable = expression(Complex);
        if (isConstant(variable)) {
            const z = fn(Complex, variable());
            return () => z;
        }
        return context => fn(Complex, variable(context));
    };
};
const binary = (data) => {
    const [lhsExpression, , punctuator, , rhsExpression] = data;
    return Complex => {
        const fn = binaryLookup[punctuator];
        const lhs = lhsExpression(Complex);
        const rhs = rhsExpression(Complex);
        if (isConstant(lhs) && isConstant(rhs)) {
            const z = fn(Complex, lhs(), rhs());
            return () => z;
        }
        return context => fn(Complex, lhs(context), rhs(context));
    };
};

// Generated automatically by nearley, version 2.19.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
const pick = (idx) => (data) => data[idx];
const empty = () => [];
const array = (...idx) => (data) => idx.map(i => data[i]);
const reduce = (acc, cur) => (data) => data[acc].concat(data[cur]);
const dispose = () => null;
const lexer = moo.compile({
    WhiteSpace: / +/,
    IdentifierName: /[$A-Z_a-z][$\w]*/,
    DecimalLiteral: /(?:(?:0|[1-9]\d*)\.?\d*|\.\d+)(?:[Ee][+-]?\d+)?/,
    BinaryIntegerLiteral: /0[Bb][01]+/,
    OctalIntegerLiteral: /0[Oo][0-7]+/,
    HexIntegerLiteral: /0[Xx][\dA-Fa-f]+/,
    // include update punctuators ++ and -- to enforce whitespace between sequential + and - punctuators
    Punctuator: ['(', ')', '[', ']', '.', ',', '+', '-', '*', '/', '%', '**', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '~'],
});
const grammar = {
    Lexer: lexer,
    ParserRules: [
        { "name": "Expression", "symbols": ["_", "BitwiseORExpression", "_"], "postprocess": pick(1) },
        { "name": "BitwiseORExpression", "symbols": ["BitwiseORExpression", "_", { "literal": "|" }, "_", "BitwiseXORExpression"], "postprocess": binary },
        { "name": "BitwiseORExpression", "symbols": ["BitwiseXORExpression"], "postprocess": id },
        { "name": "BitwiseXORExpression", "symbols": ["BitwiseXORExpression", "_", { "literal": "^" }, "_", "BitwiseANDExpression"], "postprocess": binary },
        { "name": "BitwiseXORExpression", "symbols": ["BitwiseANDExpression"], "postprocess": id },
        { "name": "BitwiseANDExpression", "symbols": ["BitwiseANDExpression", "_", { "literal": "&" }, "_", "ShiftExpression"], "postprocess": binary },
        { "name": "BitwiseANDExpression", "symbols": ["ShiftExpression"], "postprocess": id },
        { "name": "ShiftExpression", "symbols": ["ShiftExpression", "_", "ShiftOperator", "_", "AdditiveExpression"], "postprocess": binary },
        { "name": "ShiftExpression", "symbols": ["AdditiveExpression"], "postprocess": id },
        { "name": "ShiftOperator", "symbols": [{ "literal": "<<" }], "postprocess": id },
        { "name": "ShiftOperator", "symbols": [{ "literal": ">>" }], "postprocess": id },
        { "name": "ShiftOperator", "symbols": [{ "literal": ">>>" }], "postprocess": id },
        { "name": "AdditiveExpression", "symbols": ["AdditiveExpression", "_", "AdditiveOperator", "_", "MultiplicativeExpression"], "postprocess": binary },
        { "name": "AdditiveExpression", "symbols": ["MultiplicativeExpression"], "postprocess": id },
        { "name": "AdditiveOperator", "symbols": [{ "literal": "+" }], "postprocess": id },
        { "name": "AdditiveOperator", "symbols": [{ "literal": "-" }], "postprocess": id },
        { "name": "MultiplicativeExpression", "symbols": ["MultiplicativeExpression", "_", "MultiplicativeOperator", "_", "ExponentiationExpression"], "postprocess": binary },
        { "name": "MultiplicativeExpression", "symbols": ["ExponentiationExpression"], "postprocess": id },
        { "name": "MultiplicativeOperator", "symbols": [{ "literal": "*" }], "postprocess": id },
        { "name": "MultiplicativeOperator", "symbols": [{ "literal": "/" }], "postprocess": id },
        { "name": "MultiplicativeOperator", "symbols": [{ "literal": "%" }], "postprocess": id },
        { "name": "ExponentiationExpression", "symbols": ["LeftHandSideExpression", "_", { "literal": "**" }, "_", "ExponentiationExpression"], "postprocess": binary },
        { "name": "ExponentiationExpression", "symbols": ["UnaryExpression"], "postprocess": id },
        { "name": "UnaryExpression", "symbols": ["UnaryOperator", "_", "UnaryExpression"], "postprocess": unary },
        { "name": "UnaryExpression", "symbols": ["LeftHandSideExpression"], "postprocess": id },
        { "name": "UnaryOperator", "symbols": [{ "literal": "+" }], "postprocess": id },
        { "name": "UnaryOperator", "symbols": [{ "literal": "-" }], "postprocess": id },
        { "name": "UnaryOperator", "symbols": [{ "literal": "~" }], "postprocess": id },
        { "name": "LeftHandSideExpression", "symbols": ["ParenthesizedExpression"], "postprocess": id },
        { "name": "LeftHandSideExpression", "symbols": ["PrimaryExpression"], "postprocess": id },
        { "name": "ParenthesizedExpression", "symbols": [{ "literal": "(" }, "_", "BitwiseORExpression", "_", { "literal": ")" }], "postprocess": pick(2) },
        { "name": "ParenthesizedExpression", "symbols": [{ "literal": "[" }, "_", "BitwiseORExpression", "_", { "literal": "]" }], "postprocess": pick(2) },
        { "name": "PrimaryExpression", "symbols": ["CallExpression"], "postprocess": id },
        { "name": "PrimaryExpression", "symbols": [(lexer.has("IdentifierName") ? { type: "IdentifierName" } : IdentifierName)], "postprocess": identifier },
        { "name": "PrimaryExpression", "symbols": ["NumericLiteral"], "postprocess": literal },
        { "name": "NumericLiteral", "symbols": [(lexer.has("DecimalLiteral") ? { type: "DecimalLiteral" } : DecimalLiteral)], "postprocess": id },
        { "name": "NumericLiteral", "symbols": [(lexer.has("BinaryIntegerLiteral") ? { type: "BinaryIntegerLiteral" } : BinaryIntegerLiteral)], "postprocess": id },
        { "name": "NumericLiteral", "symbols": [(lexer.has("OctalIntegerLiteral") ? { type: "OctalIntegerLiteral" } : OctalIntegerLiteral)], "postprocess": id },
        { "name": "NumericLiteral", "symbols": [(lexer.has("HexIntegerLiteral") ? { type: "HexIntegerLiteral" } : HexIntegerLiteral)], "postprocess": id },
        { "name": "CallExpression", "symbols": [(lexer.has("IdentifierName") ? { type: "IdentifierName" } : IdentifierName), "_", "Arguments"], "postprocess": call },
        { "name": "Arguments", "symbols": [{ "literal": "(" }, "_", "ArgumentList", "_", { "literal": ")" }], "postprocess": pick(2) },
        { "name": "Arguments", "symbols": [{ "literal": "(" }, "_", { "literal": ")" }], "postprocess": empty },
        { "name": "ArgumentList", "symbols": ["ArgumentList", "_", { "literal": "," }, "_", "BitwiseORExpression"], "postprocess": reduce(0, 4) },
        { "name": "ArgumentList", "symbols": ["BitwiseORExpression"], "postprocess": array(0) },
        { "name": "_$ebnf$1", "symbols": [(lexer.has("WhiteSpace") ? { type: "WhiteSpace" } : WhiteSpace)], "postprocess": id },
        { "name": "_$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "_", "symbols": ["_$ebnf$1"], "postprocess": dispose }
    ],
    ParserStart: "Expression",
};

const rules = Grammar.fromCompiled(grammar);
function generate(Complex, text) {
    const parser = new Parser(rules);
    const { results } = parser.feed(text);
    switch (results.length) {
        case 0:
            throw new Error('Unexpected end of input');
        case 1:
            const [expression] = results;
            return expression(Complex);
        default:
            throw new Error('Ambiguous grammar');
    }
}

function compile(Complex, text, reviver) {
    const variable = generate(Complex, text);
    if (reviver) {
        return (...args) => variable(reviver(...args));
    }
    const z = variable({});
    return () => z;
}

function parse(Complex, text, context) {
    const variable = generate(Complex, text);
    return variable(context);
}

function polar(Complex, abs, arg = 0) {
    let zAbs;
    let zArg;
    if (abs < 0) {
        zAbs = -abs;
        zArg = arg + Math.PI;
    }
    else {
        zAbs = abs;
        zArg = arg;
    }
    return new Complex(NaN, NaN, zAbs, zArg, 12 /* HAS_POLAR */);
}

function equals(lhs, r, i = 0) {
    let rhsReal;
    let rhsImag;
    if (typeof r === 'number') {
        rhsReal = r;
        rhsImag = i;
    }
    else {
        rhsReal = getReal(r);
        rhsImag = getImag(r);
    }
    const lhsReal = getReal(lhs);
    const lhsImag = getImag(lhs);
    return lhsReal === rhsReal && lhsImag === rhsImag;
}

const fmtCoord = /%([cp])/g;
const fmtParts = /%([#0+-]{0,4})(\d{0,2})((?:\.\d{0,2})?)([Xxob]?)([rima])/g;
function toString(z, format = '%c') {
    return format
        .replace(fmtCoord, replaceCoord)
        .replace(fmtParts, replaceParts(z));
}
function replaceCoord(_, coord) {
    switch (coord) {
        case 'c': return '%r%+i*i';
        case 'p': return '%m*e**(%a*i)';
    }
}
function replaceParts(z) {
    return (_, flag, width, precision, radix, specifier) => {
        return stringify(z, {
            minus: flag.includes('-'),
            plus: flag.includes('+'),
            pound: flag.includes('#'),
            precision: precision && +precision.slice(1),
            radix: radix,
            specifier: specifier,
            width: +width,
            zero: flag.includes('0')
        });
    };
}
function stringify(z, format) {
    return width(precision(radix(specifier())));
    function specifier() {
        switch (format.specifier) {
            case 'r': return getReal(z);
            case 'i': return getImag(z);
            case 'm': return getAbs(z);
            case 'a': return getArg(z);
        }
    }
    function radix(num) {
        switch (format.radix) {
            case 'X': return num.toString(16).toUpperCase();
            case 'x': return num.toString(16).toLowerCase();
            case 'o': return num.toString(8);
            case 'b': return num.toString(2);
            case '': return num.toString(10);
        }
    }
    function precision(str) {
        const target = format.precision;
        const index = str.indexOf('.') + 1;
        if (target === '')
            return str;
        if (index === 0) {
            if (target === 0)
                return str;
            return `${str}.${'0'.repeat(target)}`;
        }
        const digits = str.length - index;
        const remove = Math.max(digits - target, 0);
        const insert = Math.max(target - digits, 0);
        return str.slice(0, str.length - remove) + '0'.repeat(insert);
    }
    function width(str) {
        if (format.minus) {
            return plus(pound(str)).padEnd(format.width, ' ');
        }
        if (!format.zero) {
            return plus(pound(str)).padStart(format.width, ' ');
        }
        if (!str.startsWith('-')) {
            return plus(pound(str.padStart(format.width, '0')));
        }
        return plus(pound(`-${str.slice(1).padStart(format.width - 1, '0')}`));
    }
    function plus(str) {
        if (!format.plus || str.startsWith('-')) {
            return str;
        }
        return `+${str}`;
    }
    function pound(str) {
        if (!format.pound || !format.radix) {
            return str;
        }
        const base = `0${format.radix}`;
        if (!str.startsWith('-')) {
            return base + str;
        }
        return `-${base + str.slice(1)}`;
    }
}

class Complex {
    /**
     * @internal
     */
    constructor(_real, _imag, _abs, _arg, _mask) {
        // coerce -0 to +0
        this._real = _real + 0;
        this._imag = _imag + 0;
        this._abs = _abs + 0;
        // choose branch cut as the interval (-pi, pi]
        this._arg = Math.PI - ((Math.PI - _arg) % (Math.PI * 2));
        this._mask = _mask;
    }
    static from(z, i) {
        return from(Complex, z, i);
    }
    static cartesian(r, i = 0) {
        return new Complex(r, i, NaN, NaN, 3 /* HAS_CARTESIAN */);
    }
    static polar(abs, arg) {
        return polar(Complex, abs, arg);
    }
    static real(z, i) {
        return real(Complex, z, i);
    }
    static imag(z, i) {
        return imag(Complex, z, i);
    }
    static abs(z, i) {
        return abs(Complex, z, i);
    }
    static arg(z, i) {
        return arg(Complex, z, i);
    }
    static neg(z, i) {
        return neg(Complex, z, i);
    }
    static conj(z, i) {
        return conj(Complex, z, i);
    }
    static floor(z, i) {
        return floor(Complex, z, i);
    }
    static ceil(z, i) {
        return ceil(Complex, z, i);
    }
    static round(z, i) {
        return round(Complex, z, i);
    }
    static sign(z, i) {
        return sign(Complex, z, i);
    }
    static trunc(z, i) {
        return trunc(Complex, z, i);
    }
    static not(z, i) {
        return not(Complex, z, i);
    }
    static random() {
        return random(Complex);
    }
    static sqrt(z, i) {
        return sqrt(Complex, z, i);
    }
    static cbrt(z, i) {
        return cbrt(Complex, z, i);
    }
    static square(z, i) {
        return square(Complex, z, i);
    }
    static cube(z, i) {
        return cube(Complex, z, i);
    }
    static exp(z, i) {
        return exp(Complex, z, i);
    }
    static log(z, i) {
        return log(Complex, z, i);
    }
    static cos(z, i) {
        return cos(Complex, z, i);
    }
    static sin(z, i) {
        return sin(Complex, z, i);
    }
    static tan(z, i) {
        return tan(Complex, z, i);
    }
    static acos(z, i) {
        return acos(Complex, z, i);
    }
    static asin(z, i) {
        return asin(Complex, z, i);
    }
    static atan(z, i) {
        return atan(Complex, z, i);
    }
    static cosh(z, i) {
        return cosh(Complex, z, i);
    }
    static sinh(z, i) {
        return sinh(Complex, z, i);
    }
    static tanh(z, i) {
        return tanh(Complex, z, i);
    }
    static acosh(z, i) {
        return acosh(Complex, z, i);
    }
    static asinh(z, i) {
        return asinh(Complex, z, i);
    }
    static atanh(z, i) {
        return atanh(Complex, z, i);
    }
    static parse(text, context) {
        return parse(Complex, text, context);
    }
    static compile(text, reviver) {
        return compile(Complex, text, reviver);
    }
    get real() {
        return getReal(this);
    }
    get imag() {
        return getImag(this);
    }
    get abs() {
        return getAbs(this);
    }
    get arg() {
        return getArg(this);
    }
    toString(format) {
        return toString(this, format);
    }
    equals(r, i) {
        return equals(this, r, i);
    }
    add(r, i) {
        return add(Complex, this, r, i);
    }
    sub(r, i) {
        return sub(Complex, this, r, i);
    }
    mul(r, i) {
        return mul(Complex, this, r, i);
    }
    div(r, i) {
        return div(Complex, this, r, i);
    }
    mod(r, i) {
        return mod(Complex, this, r, i);
    }
    pow(r, i) {
        return pow(Complex, this, r, i);
    }
    and(r, i) {
        return and(Complex, this, r, i);
    }
    or(r, i) {
        return or(Complex, this, r, i);
    }
    xor(r, i) {
        return xor(Complex, this, r, i);
    }
    sal(r, i) {
        return sal(Complex, this, r, i);
    }
    shl(r, i) {
        return sal(Complex, this, r, i);
    }
    sar(r, i) {
        return sar(Complex, this, r, i);
    }
    shr(r, i) {
        return shr(Complex, this, r, i);
    }
}
Complex['0'] = Complex.from(0);
Complex['1'] = Complex.from(1);
Complex['I'] = Complex.from(0, 1);
Complex['E'] = Complex.from(Math.E);
Complex['LN2'] = Complex.from(Math.LN2);
Complex['LN10'] = Complex.from(Math.LN10);
Complex['LOG2E'] = Complex.from(Math.LOG2E);
Complex['LOG10E'] = Complex.from(Math.LOG10E);
Complex['PI'] = Complex.from(Math.PI);
Complex['SQRT1_2'] = Complex.from(Math.SQRT1_2);
Complex['SQRT2'] = Complex.from(Math.SQRT2);

export default Complex;
